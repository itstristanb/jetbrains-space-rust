/*
 * Space
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2023.3.0-DEV.171131
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`absences_absence_reasons_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesAbsenceReasonsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_absence_reasons_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesAbsenceReasonsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_absence_reasons_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesAbsenceReasonsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_absence_reasons_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesAbsenceReasonsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_absence_reasons_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesAbsenceReasonsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_id_approve_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesIdApprovePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_id_delete_approval_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesIdDeleteApprovalDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_membermember_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesMembermemberGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`absences_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbsencesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_support_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationSupportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_enabled_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementEnabledGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_enabled_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementEnabledPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementStatusGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`administration_user_agreement_status_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdministrationUserAgreementStatusProfileGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_authorized_contexts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsAuthorizedContextsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_authorized_rights_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsAuthorizedRightsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_authorized_rights_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsAuthorizedRightsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_authorized_rights_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsAuthorizedRightsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_authorized_rights_request_rights_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsAuthorizedRightsRequestRightsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_required_rights_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsRequiredRightsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_authorizations_required_rights_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationAuthorizationsRequiredRightsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_bearer_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationBearerTokenGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_client_secret_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationClientSecretGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_client_secret_regenerate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationClientSecretRegeneratePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_force_remove_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationForceRemovePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_gpg_keys_fingerprint_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationGpgKeysFingerprintDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_gpg_keys_fingerprint_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationGpgKeysFingerprintPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_gpg_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationGpgKeysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_gpg_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationGpgKeysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_last_client_credentials_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationLastClientCredentialsAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_permanent_tokens_current_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPermanentTokensCurrentDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_permanent_tokens_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPermanentTokensGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_permanent_tokens_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPermanentTokensPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_permanent_tokens_token_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPermanentTokensTokenIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_permanent_tokens_token_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPermanentTokensTokenIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_public_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationPublicKeysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_signing_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationSigningKeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_signing_key_regenerate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationSigningKeyRegeneratePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ssh_keys_fingerprint_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationSshKeysFingerprintDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ssh_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationSshKeysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ssh_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationSshKeysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ui_extensions_disable_for_everybody_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUiExtensionsDisableForEverybodyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ui_extensions_disable_for_me_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUiExtensionsDisableForMePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ui_extensions_enable_for_everybody_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUiExtensionsEnableForEverybodyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ui_extensions_enable_for_me_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUiExtensionsEnableForMePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_ui_extensions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUiExtensionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_unfurl_domains_authorize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUnfurlDomainsAuthorizePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_unfurl_domains_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUnfurlDomainsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_unfurl_patterns_authorize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUnfurlPatternsAuthorizePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_unfurl_patterns_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationUnfurlPatternsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_verification_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationVerificationTokenGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_verification_token_regenerate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationVerificationTokenRegeneratePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_bearer_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdBearerTokenGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_custom_headers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdCustomHeadersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_custom_headers_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdCustomHeadersPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_signing_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSigningKeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_signing_key_regenerate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSigningKeyRegeneratePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_subscriptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSubscriptionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_subscriptions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSubscriptionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_subscriptions_subscription_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_subscriptions_subscription_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_application_webhooks_webhook_id_subscriptions_subscription_id_request_missing_rights_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdRequestMissingRightsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_authorizations_authorized_applications_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsAuthorizationsAuthorizedApplicationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_error_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsErrorMessagePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_paged_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsPagedGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_key_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersKeyDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersKeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_key_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersKeyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersProfileGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_profile_key_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersProfileKeyDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_profile_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersProfileKeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_parameters_profile_key_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsParametersProfileKeyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_report_application_as_healthy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsReportApplicationAsHealthyPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_ui_extensions_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUiExtensionsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_domains_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsDomainsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_patterns_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsPatternsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_queue_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsQueueContentPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_queue_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsQueueGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_queue_request_external_auth_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsQueueRequestExternalAuthPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`applications_unfurls_queue_reset_external_auth_requests_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplicationsUnfurlsQueueResetExternalAuthRequestsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_config_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesConfigDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesConfigGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesConfigPutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_discover_oidc_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesDiscoverOidcGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_logins_identifier_change_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdLoginsIdentifierChangePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_logins_identifier_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdLoginsIdentifierDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_logins_identifier_reset_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdLoginsIdentifierResetPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_id_saml_metadata_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesIdSamlMetadataPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_keykey_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesKeykeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_reorder_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesReorderPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_test_built_in_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesTestBuiltInPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_test_ldap_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesTestLdapPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_throttled_logins_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesThrottledLoginsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_throttled_logins_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesThrottledLoginsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_throttled_logins_org_status_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesThrottledLoginsOrgStatusDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_throttled_logins_org_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesThrottledLoginsOrgStatusGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_modules_usages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthModulesUsagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_features_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminFeaturesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_overdrafts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminOverdraftsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_overdrafts_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminOverdraftsPutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_reports_billing_period_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminReportsBillingPeriodGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_reports_today_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminReportsTodayGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`billing_admin_trial_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BillingAdminTrialPutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_aliasalias_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogAliasaliasGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_external_idid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogExternalIdidGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`blog_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlogStatsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_absence_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsAbsenceEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_birthday_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsBirthdayEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_birthday_events_starred_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsBirthdayEventsStarredGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_event_participations_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsEventParticipationsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_events_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsEventsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_holidays_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsHolidaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_conference_rooms_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdConferenceRoomsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_conference_rooms_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdConferenceRoomsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_participation_status_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdParticipationStatusPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_next_occurrence_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsNextOccurrenceGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_occurrences_by_meeting_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsOccurrencesByMeetingGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_occurrences_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsOccurrencesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_participation_statuses_external_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsParticipationStatusesExternalGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_participation_statuses_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsParticipationStatusesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_profile_participation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsProfileParticipationGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_meetings_profile_participation_records_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMeetingsProfileParticipationRecordsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_membership_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsMembershipEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calendars_non_working_days_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CalendarsNonWorkingDaysEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`calls_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CallsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_all_channels_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsAllChannelsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_administrator_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAdministratorGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_administrator_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAdministratorPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_archive_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelArchiveDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_attachments_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAttachmentsFilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_attachments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAttachmentsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_attachments_images_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAttachmentsImagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_attachments_links_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAttachmentsLinksGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_attachments_videos_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelAttachmentsVideosGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_description_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelDescriptionPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_icon_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelIconPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_name_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelNamePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_restore_archived_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelRestoreArchivedPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_teams_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersTeamsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_teams_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersTeamsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_users_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersUsersDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersUsersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_channel_subscribers_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsChannelSubscribersUsersPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_conversations_channel_convert_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsConversationsChannelConvertPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_conversations_channel_subject_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsConversationsChannelSubjectPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_conversations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsConversationsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_dm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsDmPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_is_name_free_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsIsNameFreePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_channels_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsChannelsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_delete_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesDeleteMessagePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_edit_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesEditMessagePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_message_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesMessageGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_pin_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesPinPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_pinned_messages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesPinnedMessagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_send_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesSendMessagePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_send_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesSendPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_sync_batch_current_etag_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesSyncBatchCurrentEtagGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_sync_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesSyncBatchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`chats_messages_unpin_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChatsMessagesUnpinPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checklists_checklist_items_plan_item_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecklistsChecklistItemsPlanItemDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checklists_checklist_items_plan_item_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecklistsChecklistItemsPlanItemGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checklists_checklist_items_plan_item_move_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecklistsChecklistItemsPlanItemMovePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checklists_checklist_items_plan_item_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecklistsChecklistItemsPlanItemPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checklists_checklist_items_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChecklistsChecklistItemsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_extended_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsExtendedTypesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_all_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyAllValuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_entity_id_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyEntityIdValuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_entity_id_values_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyEntityIdValuesPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_enum_values_custom_field_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyEnumValuesCustomFieldIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_enum_values_custom_field_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyEnumValuesCustomFieldIdPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_id_archive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsIdArchivePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_id_filter_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsIdFilterValuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_id_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsIdRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_type_key_fields_reorder_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsTypeKeyFieldsReorderPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_archive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldArchivePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_enum_values_bulk_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesBulkUpdatePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_enum_values_enum_value_to_remove_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesEnumValueToRemoveDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_enum_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_enum_values_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_enum_values_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_custom_field_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsCustomFieldRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_entity_type_fields_reorder_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2EntityTypeFieldsReorderPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_values_entity_custom_field_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2ValuesEntityCustomFieldGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_values_entity_custom_field_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2ValuesEntityCustomFieldPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_values_entity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2ValuesEntityGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`custom_fields_v2_values_entity_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CustomFieldsV2ValuesEntityPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisAddPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisDeletePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_exists_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisExistsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_frequently_used_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisFrequentlyUsedGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_record_usage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisRecordUsagePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisSearchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`emojis_sync_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EmojisSyncBatchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_default_issue_status_for_mr_merge_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesDefaultIssueStatusForMrMergePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_events_queue_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesEventsQueueGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_external_tracker_projects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesExternalTrackerProjectsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_external_tracker_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesExternalTrackerProjectsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_external_tracker_projects_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesExternalTrackerProjectsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issue_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssueContentPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issue_statuses_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssueStatusesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issues_issue_prefix_issue_id_code_reviews_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issues_issue_prefix_issue_id_code_reviews_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issues_issue_prefix_issue_id_commits_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssuesIssuePrefixIssueIdCommitsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_issues_issue_prefix_issue_id_commits_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesIssuesIssuePrefixIssueIdCommitsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_issues_mark_issues_as_deleted_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalIssuesMarkIssuesAsDeletedPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_link_patterns_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalLinkPatternsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_link_patterns_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalLinkPatternsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`external_link_patterns_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExternalLinkPatternsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`http_api_model_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HttpApiModelGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issues_get_by_ids_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssuesGetByIdsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_channel_subscriptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsChannelSubscriptionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_channel_subscriptions_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsChannelSubscriptionsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_channel_subscriptions_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsChannelSubscriptionsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_channel_subscriptions_id_request_missing_rights_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsChannelSubscriptionsIdRequestMissingRightsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_channel_subscriptions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsChannelSubscriptionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_custom_subscriptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalCustomSubscriptionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_custom_subscriptions_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalCustomSubscriptionsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_custom_subscriptions_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalCustomSubscriptionsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_custom_subscriptions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalCustomSubscriptionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_subscriptions_all_personal_subscription_targets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalSubscriptionsAllPersonalSubscriptionTargetsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_subscriptions_personal_subscription_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalSubscriptionsPersonalSubscriptionSettingsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_subscriptions_update_personal_subscription_subject_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionSubjectPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_personal_subscriptions_update_personal_subscription_target_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionTargetPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_private_feeds_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPrivateFeedsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_private_feeds_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPrivateFeedsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_private_feeds_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPrivateFeedsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_private_feeds_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsPrivateFeedsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_domains_check_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationDomainsCheckGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_domains_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationDomainsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_domains_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationDomainsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_jet_sales_license_activation_url_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationJetSalesLicenseActivationUrlGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_jet_sales_url_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationJetSalesUrlGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organization_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_create_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesCreatePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_get_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesGetPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id2_fa_requirement_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleId2FaRequirementGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id2_fa_requirement_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleId2FaRequirementPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_permissions_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdPermissionsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_permissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdPermissionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_permissions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdPermissionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdProfilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_profiles_profile_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdProfilesProfileDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_profiles_profile_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdProfilesProfilePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_reset_role_permissions_to_default_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdResetRolePermissionsToDefaultPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_teams_team_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdTeamsTeamDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_roles_role_id_teams_team_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRolesRoleIdTeamsTeamPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permissions_check_permission_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionsCheckPermissionPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_deployment_targets_audit_log_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationDeploymentTargetsAuditLogGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_deployment_targets_full_number_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationDeploymentTargetsFullNumberIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_deployment_targets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationDeploymentTargetsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_deployment_targets_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationDeploymentTargetsSearchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_dsl_evaluations_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationDslEvaluationsConfigGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_graph_executions_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationGraphExecutionsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_graph_executions_id_stop_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationGraphExecutionsIdStopPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_job_executions_current_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationJobExecutionsCurrentGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_jobs_job_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationJobsJobIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_step_executions_step_exec_id_parameters_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationStepExecutionsStepExecIdParametersKeyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_step_executions_step_exec_id_parameters_key_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationStepExecutionsStepExecIdParametersKeyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_step_executions_used_parameters_param_parameter_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationStepExecutionsUsedParametersParamParameterIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_step_executions_used_parameters_secret_secret_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationStepExecutionsUsedParametersSecretSecretIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_automation_subscriptions_legacy_channels_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsAutomationSubscriptionsLegacyChannelsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_collaboratorprofile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsCollaboratorprofileGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_membermember_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsMembermemberGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_default_bundle_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsDefaultBundleGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_default_bundle_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsDefaultBundlePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_in_default_bundle_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsInDefaultBundleGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_params_in_default_bundle_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsParamsInDefaultBundlePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_issues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardIssuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_issues_issue_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardIssuesIssueDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_issues_issue_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardIssuesIssuePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_board_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsBoardPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_archive_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintArchiveDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_issues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintIssuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_issues_issue_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintIssuesIssueDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_issues_issue_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintIssuesIssuePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_launch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintLaunchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_planning_boards_sprints_sprint_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPlanningBoardsSprintsSprintPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_private_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPrivateProjectsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_private_projects_project_request_access_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsPrivateProjectsProjectRequestAccessPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_admins_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessAdminsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_admins_profiles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessAdminsProfilesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_admins_profiles_profile_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessAdminsProfilesProfileDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_admins_teams_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessAdminsTeamsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_admins_teams_team_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessAdminsTeamsTeamIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_profiles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsProfilesDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsProfilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_profiles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsProfilesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_teams_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsTeamsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_collaborators_teams_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessCollaboratorsTeamsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_member_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessMemberProfilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_members_profiles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessMembersProfilesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_members_profiles_profile_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessMembersProfilesProfileDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_members_teams_team_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessMembersTeamsTeamIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_access_viewers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAccessViewersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_favorites_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsFavoritesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_target_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsTargetDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_target_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsTargetGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployment_targets_target_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentTargetsTargetPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsFailPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_finish_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsFinishPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_schedule_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsSchedulePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_start_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsStartPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_target_identifier_deployment_identifier_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_deployments_target_identifier_deployment_identifier_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_graph_executions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationGraphExecutionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_jobs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationJobsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_automation_jobs_job_id_start_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectAutomationJobsJobIdStartPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_code_discussions_discussion_id_accept_suggested_edit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdAcceptSuggestedEditPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_code_discussions_discussion_id_reject_suggested_edit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdRejectSuggestedEditPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_code_discussions_discussion_id_reopen_suggested_edit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdReopenSuggestedEditPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_code_discussions_discussion_id_suggested_edit_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdSuggestedEditPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_code_discussions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCodeDiscussionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_commit_set_review_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsCommitSetReviewPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_merge_requests_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsMergeRequestsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_description_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdDescriptionPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdDetailsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdFilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_make_read_only_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdMakeReadOnlyPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_merge_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdMergeFilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_merge_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdMergePutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_participants_user_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdParticipantsUserDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_participants_user_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdParticipantsUserPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_rebase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdRebasePutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_revisions_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdRevisionsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_revisions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdRevisionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_state_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdStatePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_suggested_reviewers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdSuggestedReviewersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_title_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdTitlePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_unbound_discussions_discussion_id_toggle_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsDiscussionIdTogglePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_unbound_discussions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_review_id_unbound_discussions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_safe_merge_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsSafeMergeDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_safe_merge_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsSafeMergeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_code_reviews_safe_merge_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectCodeReviewsSafeMergePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_access_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdAccessPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_copy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdCopyPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_move_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdMovePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_document_id_unarchive_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsDocumentIdUnarchivePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_access_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderAccessPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_documents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderDocumentsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_introduction_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderIntroductionDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_introduction_document_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderIntroductionDocumentIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_move_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderMovePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderSearchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_folder_subfolders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersFolderSubfoldersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_folders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsFoldersPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_documents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectDocumentsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_feature_pins_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectFeaturePinsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_access_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryAccessPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_cleanup_dry_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryCleanupDryPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_cleanup_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryCleanupPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_connections_connection_id_publish_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_connections_connection_id_publish_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_connections_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryConnectionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_files_folderfolder_path_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryFilesFolderfolderPathDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryFilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_files_namefile_path_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_files_namefile_path_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_metadata_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_metadata_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataPutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_metadata_versionpackage_version_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataVersionpackageVersionPutError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_versions_versionpackage_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_packages_namepackage_name_versions_versionpackage_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_repository_url_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesRepositoryUrlGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_typetype_repositoryrepository_name_packages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_versionpackage_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_versionpackage_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesSearchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_packages_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPackagesTypesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_members_by_ids_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleMembersByIdsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_members_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleMembersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_members_profile_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleMembersProfileDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_members_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleMembersUpdatePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_teams_by_ids_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleTeamsByIdsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_teams_team_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleTeamsTeamDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_people_teams_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPeopleTeamsUpdatePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_personal_feature_pins_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPersonalFeaturePinsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_boards_board_archive_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningBoardsBoardArchiveDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_boards_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningBoardsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_boards_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningBoardsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_boards_sprints_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningBoardsSprintsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_boards_starred_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningBoardsStarredGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_checklist_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsChecklistIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_checklist_id_full_checklist_tree_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsChecklistIdFullChecklistTreeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_checklist_id_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsChecklistIdImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_checklist_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsChecklistIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_checklists_starred_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningChecklistsStarredGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_fields_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesFieldsOrderGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_fields_order_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesFieldsOrderPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_fields_visibility_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesFieldsVisibilityGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_fields_visibility_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesFieldsVisibilityPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_attachment_attachment_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdAttachmentAttachmentIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_attachment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdAttachmentPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_attachments_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdAttachmentsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_attachments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdAttachmentsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_checklists_checklist_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_checklists_checklist_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_code_reviews_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdCodeReviewsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_code_reviews_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdCodeReviewsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_comments_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdCommentsImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_commits_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdCommitsDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_commits_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdCommitsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_tags_tag_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdTagsTagIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_tags_tag_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdTagsTagIdPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_issue_id_toggle_resolved_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesIssueIdToggleResolvedPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_numbernumber_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesNumbernumberGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_statuses_distribution_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesStatusesDistributionGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_statuses_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesStatusesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_statuses_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesStatusesPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_issues_sync_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningIssuesSyncBatchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningTagsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_planning_tags_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectPlanningTagsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_additional_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryAdditionalInfoGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_changes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryChangesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_cherry_pick_commit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryCherryPickCommitPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_commit_branches_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryCommitBranchesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_commit_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryCommitPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_commits_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryCommitsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_default_branch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryDefaultBranchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_default_branch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryDefaultBranchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_delete_branch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryDeleteBranchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_description_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryDescriptionPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryFilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_gc_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryGcPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_head_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryHeadPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_heads_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryHeadsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_inline_merge_diff_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryInlineMergeDiffGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_merge_branch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryMergeBranchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_merge_preview_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryMergePreviewGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_merge_preview_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryMergePreviewStatusGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_migrate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryMigratePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_readonly_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryReadonlyGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_readonly_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryReadonlyPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_rebase_branch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryRebaseBranchPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_revisions_revision_external_checks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_revisions_revision_external_checks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositorySettingsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_settings_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositorySettingsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_repository_url_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesRepositoryUrlGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_repositories_test_connection_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectRepositoriesTestConnectionPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_responsibilities_responsibility_id_assignees_profile_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_responsibilities_responsibility_id_assignees_profile_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_responsibilities_scheme_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectResponsibilitiesSchemeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_responsibilities_subjects_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectResponsibilitiesSubjectsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_project_responsibilities_subjects_subject_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsProjectResponsibilitiesSubjectsSubjectIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_repositories_find_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsRepositoriesFindGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_responsibilities_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsResponsibilitiesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_responsibilities_responsibility_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsResponsibilitiesResponsibilityIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_responsibilities_responsibility_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsResponsibilitiesResponsibilityIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_responsibilities_subjects_subject_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsResponsibilitiesSubjectsSubjectIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_right_coderight_code_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsRightCoderightCodeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_right_unique_coderight_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsRightUniqueCoderightGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_default_bundle_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsDefaultBundleGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_default_bundle_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsDefaultBundlePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_in_default_bundle_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsInDefaultBundleGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_secrets_in_default_bundle_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsSecretsInDefaultBundlePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsTagsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_tags_track_access_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsTagsTrackAccessPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_teamteam_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsTeamteamGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_vault_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsVaultGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_vault_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsVaultIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_vault_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsVaultIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`projects_vault_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectsVaultPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_calendars_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysCalendarsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_calendars_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysCalendarsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_calendars_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysCalendarsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_calendars_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysCalendarsImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_calendars_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysCalendarsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_profile_holidays_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysProfileHolidaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`public_holidays_holidays_related_holidays_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublicHolidaysHolidaysRelatedHolidaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_item_emoji_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsItemEmojiDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_item_emoji_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsItemEmojiGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_item_emoji_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsItemEmojiPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reactions_item_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactionsItemGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rich_text_parse_markdown_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RichTextParseMarkdownPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_absence_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsAbsenceEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_birthday_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsBirthdayEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_birthday_events_starred_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsBirthdayEventsStarredGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_holidays_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsHolidaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_meeting_participations_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsMeetingParticipationsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_membership_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsMembershipEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_calendar_events_non_working_days_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryCalendarEventsNonWorkingDaysEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitation_links_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationLinksGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitation_links_invitation_link_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationLinksInvitationLinkIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitation_links_invitation_link_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationLinksInvitationLinkIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitation_links_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationLinksPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitations_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitations_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_invitations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryInvitationsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_languages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLanguagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_equipment_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationEquipmentTypesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_equipment_types_namename_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationEquipmentTypesNamenameDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_map_member_points_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationMapMemberPointsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_map_member_points_location_point_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationMapMemberPointsLocationPointIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_map_member_points_location_point_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationMapMemberPointsLocationPointIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_location_map_member_points_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationMapMemberPointsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_map_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdMapGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_map_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdMapPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_id_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsIdRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_locations_with_timezone_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryLocationsWithTimezoneGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_member_locations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMemberLocationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_member_locations_member_location_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMemberLocationsMemberLocationIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_member_locations_member_location_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMemberLocationsMemberLocationIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_member_locations_member_location_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMemberLocationsMemberLocationIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_member_locations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMemberLocationsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_membership_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipEventsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_manager_candidates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsManagerCandidatesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_membership_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsMembershipIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_membership_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsMembershipIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_membership_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsMembershipIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_membership_id_request_revoke_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsMembershipIdRequestRevokePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_membership_id_revoke_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsMembershipIdRevokeDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_requests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsRequestsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_requests_membership_request_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsRequestsMembershipRequestIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_requests_membership_request_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsRequestsMembershipRequestIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_memberships_sync_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryMembershipsSyncBatchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_authentication_sessions_owner_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesAuthenticationSessionsOwnerGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_authentication_sessions_owner_session_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesAuthenticationSessionsOwnerSessionIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_dashboards_dashboard_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesDashboardsDashboardGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_dashboards_dashboard_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesDashboardsDashboardPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_emailemail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesEmailemailGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_deployment_targets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesDeploymentTargetsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_documents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesDocumentsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_jobs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesJobsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_locations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesLocationsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesProfilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesProjectsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_repositories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesRepositoriesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_favorites_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesFavoritesTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_oauth_consents_owner_applications_application_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesOauthConsentsOwnerApplicationsApplicationDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_oauth_consents_owner_approved_scopes_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesOauthConsentsOwnerApprovedScopesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_oauth_consents_owner_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesOauthConsentsOwnerGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_oauth_consents_owner_internal_applications_client_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesOauthConsentsOwnerInternalApplicationsClientIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_oauth_consents_owner_refresh_tokens_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesOauthConsentsOwnerRefreshTokensIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_requirements_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaRequirementsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaStatusGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_totp_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaTotpConfirmPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_totp_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaTotpDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_totp_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaTotpPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile2_fa_totp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfile2FaTotpPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_application_passwords_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileApplicationPasswordsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_application_passwords_password_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_application_passwords_password_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_application_passwords_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileApplicationPasswordsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_checklist_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsChecklistIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_checklist_id_full_checklist_tree_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsChecklistIdFullChecklistTreeGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_checklist_id_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsChecklistIdImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_checklist_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsChecklistIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsImportPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_checklists_starred_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileChecklistsStarredGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_convert_to_guest_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileConvertToGuestPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_convert_to_member_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileConvertToMemberPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_deactivate_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDeactivateDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_access_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdAccessPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_copy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdCopyPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_move_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdMovePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_document_id_unarchive_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsDocumentIdUnarchivePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_access_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_access_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_documents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderDocumentsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_introduction_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_introduction_document_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDocumentIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_move_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderMovePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderSearchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_folder_subfolders_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersFolderSubfoldersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_folders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsFoldersPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_documents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileDocumentsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_gpg_keys_fingerprint_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileGpgKeysFingerprintDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_gpg_keys_fingerprint_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileGpgKeysFingerprintPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_gpg_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileGpgKeysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_gpg_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileGpgKeysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_is_team_member_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileIsTeamMemberGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_leads_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileLeadsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_nav_bar_menu_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNavBarMenuItemsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_nav_bar_menu_items_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNavBarMenuItemsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_nav_bar_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNavBarProjectsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_nav_bar_projects_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNavBarProjectsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_nav_bar_projects_project_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNavBarProjectsProjectDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_notification_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNotificationSettingsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_notification_settings_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileNotificationSettingsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_permanent_tokens_current_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePermanentTokensCurrentDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_permanent_tokens_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePermanentTokensGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_permanent_tokens_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePermanentTokensPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_permanent_tokens_token_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePermanentTokensTokenIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_permanent_tokens_token_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfilePermanentTokensTokenIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_reactivate_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileReactivatePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_restore_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileRestorePatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSettingsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_settings_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSettingsPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_spoken_languages_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSpokenLanguagesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_spoken_languages_language_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSpokenLanguagesLanguageDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_spoken_languages_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSpokenLanguagesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_ssh_keys_fingerprint_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSshKeysFingerprintDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_ssh_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSshKeysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_ssh_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSshKeysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_suspend_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileSuspendPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_timezone_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileTimezoneGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_working_days_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileWorkingDaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_working_days_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileWorkingDaysPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_working_days_working_days_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_profile_working_days_working_days_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_widget_settings_widget_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesWidgetSettingsWidgetGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_widget_settings_widget_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesWidgetSettingsWidgetPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_profiles_working_days_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryProfilesWorkingDaysGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_id_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesIdRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_roles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryRolesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_stats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryStatsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_cancel_disbanding_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdCancelDisbandingPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_direct_members_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdDirectMembersGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_disband_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdDisbandDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_id_restore_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsIdRestorePostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`team_directory_teams_sync_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamDirectoryTeamsSyncBatchGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`time_tracking_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimeTrackingItemsGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`time_tracking_items_item_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimeTrackingItemsItemIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`time_tracking_items_item_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimeTrackingItemsItemIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`time_tracking_items_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimeTrackingItemsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`todo_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TodoGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`todo_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TodoIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`todo_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TodoIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`todo_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TodoPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trusted_certificates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrustedCertificatesGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trusted_certificates_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrustedCertificatesIdDeleteError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trusted_certificates_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrustedCertificatesIdPatchError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trusted_certificates_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrustedCertificatesInfoGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`trusted_certificates_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrustedCertificatesPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_block_unfurl_global_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsBlockUnfurlGlobalPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_block_unfurl_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsBlockUnfurlPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_check_blocked_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsCheckBlockedPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_list_blocked_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsListBlockedGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_unblock_unfurl_global_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsUnblockUnfurlGlobalPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unfurls_unblock_unfurl_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnfurlsUnblockUnfurlPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uploads_chat_public_url_channel_message_attachment_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadsChatPublicUrlChannelMessageAttachmentIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uploads_image_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadsImageIdGetError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uploads_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadsPostError {
    DefaultResponse(crate::models::AbsencesGetDefaultResponse),
    UnknownValue(serde_json::Value),
}


/// Get available absence reasons
pub async fn absences_absence_reasons_get(configuration: &configuration::Configuration, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AbsenceReasonRecord>, Error<AbsencesAbsenceReasonsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/absence-reasons", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesAbsenceReasonsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive/restore an existing absence reason. Setting delete to true will archive the absence reason, false will restore it.
pub async fn absences_absence_reasons_id_delete(configuration: &configuration::Configuration, id: &str, delete: Option<bool>) -> Result<(), Error<AbsencesAbsenceReasonsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/absence-reasons/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AbsencesAbsenceReasonsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an absence reason
pub async fn absences_absence_reasons_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceReasonRecord, Error<AbsencesAbsenceReasonsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/absence-reasons/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesAbsenceReasonsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing absence reason
pub async fn absences_absence_reasons_id_patch(configuration: &configuration::Configuration, id: &str, absences_absence_reasons_post_request: crate::models::AbsencesAbsenceReasonsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceReasonRecord, Error<AbsencesAbsenceReasonsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/absence-reasons/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&absences_absence_reasons_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesAbsenceReasonsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new absence reason
pub async fn absences_absence_reasons_post(configuration: &configuration::Configuration, absences_absence_reasons_post_request: crate::models::AbsencesAbsenceReasonsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceReasonRecord, Error<AbsencesAbsenceReasonsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/absence-reasons", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&absences_absence_reasons_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesAbsenceReasonsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search absences. Parameters are applied as 'AND' filters.
pub async fn absences_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, member: Option<&str>, members: Option<Vec<String>>, location: Option<&str>, team: Option<&str>, since: Option<&str>, till: Option<&str>, view_mode: Option<AbsenceListMode>, reason: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::AbsencesGet200Response, Error<AbsencesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = member {
        local_var_req_builder = local_var_req_builder.query(&[("member", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = members {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("members".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("members", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = view_mode {
        local_var_req_builder = local_var_req_builder.query(&[("viewMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reason {
        local_var_req_builder = local_var_req_builder.query(&[("reason", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Approve/unapprove an existing absence. Setting approve to true will approve the absence, false will remove the approval.
pub async fn absences_id_approve_post(configuration: &configuration::Configuration, id: &str, absences_id_approve_post_request: crate::models::AbsencesIdApprovePostRequest) -> Result<(), Error<AbsencesIdApprovePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/{id}/approve", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&absences_id_approve_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AbsencesIdApprovePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive/restore an existing absence. Setting delete to true will archive the absence, false will restore it.
pub async fn absences_id_delete(configuration: &configuration::Configuration, id: &str, delete: Option<bool>) -> Result<(), Error<AbsencesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AbsencesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete approval for a given absence
pub async fn absences_id_delete_approval_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<AbsencesIdDeleteApprovalDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/{id}/delete-approval", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AbsencesIdDeleteApprovalDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an absence
pub async fn absences_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceRecord, Error<AbsencesIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing absence. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn absences_id_patch(configuration: &configuration::Configuration, id: &str, absences_id_patch_request: crate::models::AbsencesIdPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceRecord, Error<AbsencesIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&absences_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get absences for a given profile ID
pub async fn absences_membermember_get(configuration: &configuration::Configuration, member: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AbsenceRecord>, Error<AbsencesMembermemberGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences/member:{member}", local_var_configuration.base_path, member=crate::apis::urlencode(member));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesMembermemberGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create an absence for a given profile (member)
pub async fn absences_post(configuration: &configuration::Configuration, absences_post_request: crate::models::AbsencesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::AbsenceRecord, Error<AbsencesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/absences", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&absences_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbsencesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a profile for support
pub async fn administration_support_post(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::SupportProfileDto, Error<AdministrationSupportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/support", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationSupportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_enabled_get(configuration: &configuration::Configuration, ) -> Result<bool, Error<AdministrationUserAgreementEnabledGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement/enabled", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationUserAgreementEnabledGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_enabled_post(configuration: &configuration::Configuration, administration_user_agreement_enabled_post_request: crate::models::AdministrationUserAgreementEnabledPostRequest) -> Result<(), Error<AdministrationUserAgreementEnabledPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement/enabled", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&administration_user_agreement_enabled_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdministrationUserAgreementEnabledPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::UaUserAgreement, Error<AdministrationUserAgreementGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationUserAgreementGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_patch(configuration: &configuration::Configuration, administration_user_agreement_patch_request: crate::models::AdministrationUserAgreementPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::UaUserAgreement, Error<AdministrationUserAgreementPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&administration_user_agreement_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationUserAgreementPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_status_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, accepted: Option<bool>, active_profiles_only: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::AdministrationUserAgreementStatusGet200Response, Error<AdministrationUserAgreementStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement/status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = accepted {
        local_var_req_builder = local_var_req_builder.query(&[("accepted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = active_profiles_only {
        local_var_req_builder = local_var_req_builder.query(&[("activeProfilesOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationUserAgreementStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn administration_user_agreement_status_profile_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::UaUserAgreementStatus, Error<AdministrationUserAgreementStatusProfileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/administration/user-agreement/status/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdministrationUserAgreementStatusProfileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List authorized contexts of an application
pub async fn applications_application_authorizations_authorized_contexts_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PermissionContextApi>, Error<ApplicationsApplicationAuthorizationsAuthorizedContextsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/authorized-contexts", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsAuthorizedContextsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove application authorization in specified context
pub async fn applications_application_authorizations_authorized_rights_delete(configuration: &configuration::Configuration, application: &str, context_identifier: &str) -> Result<(), Error<ApplicationsApplicationAuthorizationsAuthorizedRightsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/authorized-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("contextIdentifier", &context_identifier.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsAuthorizedRightsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List authorized rights of an application in specified context
pub async fn applications_application_authorizations_authorized_rights_get(configuration: &configuration::Configuration, application: &str, context_identifier: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::RightDto>, Error<ApplicationsApplicationAuthorizationsAuthorizedRightsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/authorized-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("contextIdentifier", &context_identifier.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsAuthorizedRightsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Generic method for editing authorized right status in given context.
pub async fn applications_application_authorizations_authorized_rights_patch(configuration: &configuration::Configuration, application: &str, applications_application_authorizations_authorized_rights_patch_request: crate::models::ApplicationsApplicationAuthorizationsAuthorizedRightsPatchRequest) -> Result<(), Error<ApplicationsApplicationAuthorizationsAuthorizedRightsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/authorized-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_authorizations_authorized_rights_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsAuthorizedRightsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request rights for an application in specified context
pub async fn applications_application_authorizations_authorized_rights_request_rights_patch(configuration: &configuration::Configuration, application: &str, applications_application_authorizations_authorized_rights_request_rights_patch_request: crate::models::ApplicationsApplicationAuthorizationsAuthorizedRightsRequestRightsPatchRequest) -> Result<(), Error<ApplicationsApplicationAuthorizationsAuthorizedRightsRequestRightsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/authorized-rights/request-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_authorizations_authorized_rights_request_rights_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsAuthorizedRightsRequestRightsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List required rights for an application
pub async fn applications_application_authorizations_required_rights_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::RightDto>, Error<ApplicationsApplicationAuthorizationsRequiredRightsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/required-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsRequiredRightsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update list of required rights for an application
pub async fn applications_application_authorizations_required_rights_patch(configuration: &configuration::Configuration, application: &str, applications_application_authorizations_required_rights_patch_request: crate::models::ApplicationsApplicationAuthorizationsRequiredRightsPatchRequest) -> Result<(), Error<ApplicationsApplicationAuthorizationsRequiredRightsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/authorizations/required-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_authorizations_required_rights_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationAuthorizationsRequiredRightsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_bearer_token_get(configuration: &configuration::Configuration, application: &str) -> Result<String, Error<ApplicationsApplicationBearerTokenGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/bearer-token", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationBearerTokenGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_client_secret_get(configuration: &configuration::Configuration, application: &str) -> Result<String, Error<ApplicationsApplicationClientSecretGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/client-secret", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationClientSecretGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_client_secret_regenerate_post(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationClientSecretRegeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/client-secret/regenerate", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationClientSecretRegeneratePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes specified application. If the application is connected (installed from Marketplace or through an install link), Space sends `ApplicationUninstalledPayload` to the application's server. The application is only actually deleted when the application server responds or when the `ApplicationUninstalledPayload` request times out multiple times.  This API method does not wait until the `ApplicationUninstalledPayload` request is finished and instead returns immediately. Consequently, the application may still be active right after this API method call.  If sending `ApplicationUninstalledPayload` has failed at least one time, a user may choose to force-remove the application. In this case the access for the application is terminated and it can no longer make requests. 
pub async fn applications_application_delete(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes the application that has previously failed to respond with code 200 to `ApplicationUninstalledPayload` request, without sending additional `ApplicationUninstalledPayload` requests. The application is archived and its access terminated.
pub async fn applications_application_force_remove_post(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationForceRemovePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/force-remove", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationForceRemovePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<crate::models::EsApp, Error<ApplicationsApplicationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_gpg_keys_fingerprint_delete(configuration: &configuration::Configuration, application: &str, fingerprint: &str) -> Result<(), Error<ApplicationsApplicationGpgKeysFingerprintDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/gpg-keys/{fingerprint}", local_var_configuration.base_path, application=crate::apis::urlencode(application), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationGpgKeysFingerprintDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_gpg_keys_fingerprint_patch(configuration: &configuration::Configuration, application: &str, fingerprint: &str, applications_application_gpg_keys_fingerprint_patch_request: Option<crate::models::ApplicationsApplicationGpgKeysFingerprintPatchRequest>) -> Result<(), Error<ApplicationsApplicationGpgKeysFingerprintPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/gpg-keys/{fingerprint}", local_var_configuration.base_path, application=crate::apis::urlencode(application), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_gpg_keys_fingerprint_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationGpgKeysFingerprintPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_gpg_keys_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::GpgKeyData>, Error<ApplicationsApplicationGpgKeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/gpg-keys", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationGpgKeysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_gpg_keys_post(configuration: &configuration::Configuration, application: &str, applications_application_gpg_keys_post_request: crate::models::ApplicationsApplicationGpgKeysPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GpgKeyData, Error<ApplicationsApplicationGpgKeysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/gpg-keys", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_gpg_keys_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationGpgKeysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_last_client_credentials_access_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<crate::models::AccessRecord, Error<ApplicationsApplicationLastClientCredentialsAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/last-client-credentials-access", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationLastClientCredentialsAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update existing application. Multi-org applications (created with the parameter `connectToSpace = true` or installed from JetBrains Marketplace) can only be updated by the application itself. Learn more about multi-org applications in the [documentation](https://www.jetbrains.com/help/space/distribute-your-application.html).
pub async fn applications_application_patch(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>, applications_application_patch_request: Option<crate::models::ApplicationsApplicationPatchRequest>) -> Result<crate::models::EsApp, Error<ApplicationsApplicationPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete personal token of the given application
pub async fn applications_application_permanent_tokens_current_delete(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationPermanentTokensCurrentDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/permanent-tokens/current", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationPermanentTokensCurrentDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get permanent tokens used to access the current organization by the given application
pub async fn applications_application_permanent_tokens_get(configuration: &configuration::Configuration, application: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ApplicationsApplicationPermanentTokensGet200Response, Error<ApplicationsApplicationPermanentTokensGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/permanent-tokens", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationPermanentTokensGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a permanent token for the given application that can be used to access the current organization
pub async fn applications_application_permanent_tokens_post(configuration: &configuration::Configuration, application: &str, applications_application_permanent_tokens_post_request: crate::models::ApplicationsApplicationPermanentTokensPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ApplicationsApplicationPermanentTokensPost200Response, Error<ApplicationsApplicationPermanentTokensPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/permanent-tokens", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_permanent_tokens_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationPermanentTokensPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a personal token used to access the current organization
pub async fn applications_application_permanent_tokens_token_id_delete(configuration: &configuration::Configuration, application: &str, token_id: &str) -> Result<(), Error<ApplicationsApplicationPermanentTokensTokenIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/permanent-tokens/{tokenId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), tokenId=crate::apis::urlencode(token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationPermanentTokensTokenIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing personal token used to access the current organization. The permanent token's name and/or scope can be updated.
pub async fn applications_application_permanent_tokens_token_id_patch(configuration: &configuration::Configuration, application: &str, token_id: &str, applications_application_permanent_tokens_token_id_patch_request: Option<crate::models::ApplicationsApplicationPermanentTokensTokenIdPatchRequest>) -> Result<(), Error<ApplicationsApplicationPermanentTokensTokenIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/permanent-tokens/{tokenId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), tokenId=crate::apis::urlencode(token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_permanent_tokens_token_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationPermanentTokensTokenIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns list of public keys in JWKS format. If message signature is successfully verified with any of the returned public keys, the message can be considered authentic.
pub async fn applications_application_public_keys_get(configuration: &configuration::Configuration, application: &str) -> Result<String, Error<ApplicationsApplicationPublicKeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/public-keys", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationPublicKeysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_restore_post(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/restore", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_signing_key_get(configuration: &configuration::Configuration, application: &str) -> Result<String, Error<ApplicationsApplicationSigningKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/signing-key", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationSigningKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_signing_key_regenerate_post(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationSigningKeyRegeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/signing-key/regenerate", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationSigningKeyRegeneratePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_ssh_keys_fingerprint_delete(configuration: &configuration::Configuration, application: &str, fingerprint: &str) -> Result<(), Error<ApplicationsApplicationSshKeysFingerprintDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ssh-keys/{fingerprint}", local_var_configuration.base_path, application=crate::apis::urlencode(application), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationSshKeysFingerprintDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_ssh_keys_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SshKeyData>, Error<ApplicationsApplicationSshKeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ssh-keys", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationSshKeysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_ssh_keys_post(configuration: &configuration::Configuration, application: &str, applications_application_ssh_keys_post_request: crate::models::ApplicationsApplicationSshKeysPostRequest) -> Result<(), Error<ApplicationsApplicationSshKeysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ssh-keys", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ssh_keys_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationSshKeysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disable application UI for everybody in specified context. Requires Superadmin right for global context, AdminProject for project context, AdminChannel for channel context. Users will still be able to enable application UI individually.
pub async fn applications_application_ui_extensions_disable_for_everybody_patch(configuration: &configuration::Configuration, application: &str, applications_application_ui_extensions_disable_for_everybody_patch_request: crate::models::ApplicationsApplicationUiExtensionsDisableForEverybodyPatchRequest) -> Result<(), Error<ApplicationsApplicationUiExtensionsDisableForEverybodyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ui-extensions/disable-for-everybody", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ui_extensions_disable_for_everybody_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUiExtensionsDisableForEverybodyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disable application UI in specified context for the current user
pub async fn applications_application_ui_extensions_disable_for_me_patch(configuration: &configuration::Configuration, application: &str, applications_application_ui_extensions_disable_for_everybody_patch_request: crate::models::ApplicationsApplicationUiExtensionsDisableForEverybodyPatchRequest) -> Result<(), Error<ApplicationsApplicationUiExtensionsDisableForMePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ui-extensions/disable-for-me", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ui_extensions_disable_for_everybody_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUiExtensionsDisableForMePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enable application UI for everybody in specified context. Requires Superadmin right for global context, AdminProject for project context, AdminChannel for channel context. Users will still be able to disable application UI individually.
pub async fn applications_application_ui_extensions_enable_for_everybody_patch(configuration: &configuration::Configuration, application: &str, applications_application_ui_extensions_disable_for_everybody_patch_request: crate::models::ApplicationsApplicationUiExtensionsDisableForEverybodyPatchRequest) -> Result<(), Error<ApplicationsApplicationUiExtensionsEnableForEverybodyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ui-extensions/enable-for-everybody", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ui_extensions_disable_for_everybody_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUiExtensionsEnableForEverybodyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enable application UI in specified context for the current user
pub async fn applications_application_ui_extensions_enable_for_me_patch(configuration: &configuration::Configuration, application: &str, applications_application_ui_extensions_disable_for_everybody_patch_request: crate::models::ApplicationsApplicationUiExtensionsDisableForEverybodyPatchRequest) -> Result<(), Error<ApplicationsApplicationUiExtensionsEnableForMePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ui-extensions/enable-for-me", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ui_extensions_disable_for_everybody_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUiExtensionsEnableForMePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get UI extensions supported by the application in specified context. Omit contextIdentifier to get UI extensions in all contexts
pub async fn applications_application_ui_extensions_get(configuration: &configuration::Configuration, application: &str, context_identifier: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AppUiExtensionApi>, Error<ApplicationsApplicationUiExtensionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/ui-extensions", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("contextIdentifier", &context_identifier.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationUiExtensionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Authorize domains for unfurling by the application
pub async fn applications_application_unfurl_domains_authorize_post(configuration: &configuration::Configuration, application: &str, applications_application_unfurl_domains_authorize_post_request: crate::models::ApplicationsApplicationUnfurlDomainsAuthorizePostRequest) -> Result<(), Error<ApplicationsApplicationUnfurlDomainsAuthorizePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/unfurl-domains/authorize", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_unfurl_domains_authorize_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUnfurlDomainsAuthorizePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List domains for unfurling by the application
pub async fn applications_application_unfurl_domains_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ApplicationUnfurlDomain>, Error<ApplicationsApplicationUnfurlDomainsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/unfurl-domains", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationUnfurlDomainsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Authorize patterns for unfurling by the application
pub async fn applications_application_unfurl_patterns_authorize_post(configuration: &configuration::Configuration, application: &str, applications_application_unfurl_patterns_authorize_post_request: crate::models::ApplicationsApplicationUnfurlPatternsAuthorizePostRequest) -> Result<(), Error<ApplicationsApplicationUnfurlPatternsAuthorizePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/unfurl-patterns/authorize", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_unfurl_patterns_authorize_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationUnfurlPatternsAuthorizePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List patterns for unfurling by the application
pub async fn applications_application_unfurl_patterns_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ApplicationUnfurlPattern>, Error<ApplicationsApplicationUnfurlPatternsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/unfurl-patterns", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationUnfurlPatternsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_verification_token_get(configuration: &configuration::Configuration, application: &str) -> Result<String, Error<ApplicationsApplicationVerificationTokenGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/verification-token", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationVerificationTokenGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_verification_token_regenerate_post(configuration: &configuration::Configuration, application: &str) -> Result<(), Error<ApplicationsApplicationVerificationTokenRegeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/verification-token/regenerate", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationVerificationTokenRegeneratePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get application webhooks
pub async fn applications_application_webhooks_get(configuration: &configuration::Configuration, application: &str, with_archived: Option<bool>, query: Option<&str>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ApplicationsApplicationWebhooksGet200Response, Error<ApplicationsApplicationWebhooksGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create application webhook
pub async fn applications_application_webhooks_post(configuration: &configuration::Configuration, application: &str, applications_application_webhooks_post_request: crate::models::ApplicationsApplicationWebhooksPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::WebhookRecord, Error<ApplicationsApplicationWebhooksPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks", local_var_configuration.base_path, application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_webhooks_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_webhooks_webhook_id_bearer_token_get(configuration: &configuration::Configuration, application: &str, webhook_id: &str) -> Result<String, Error<ApplicationsApplicationWebhooksWebhookIdBearerTokenGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/bearer-token", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdBearerTokenGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_webhooks_webhook_id_custom_headers_get(configuration: &configuration::Configuration, application: &str, webhook_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CustomHttpHeaderDto>, Error<ApplicationsApplicationWebhooksWebhookIdCustomHeadersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/custom-headers", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdCustomHeadersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_webhooks_webhook_id_custom_headers_post(configuration: &configuration::Configuration, application: &str, webhook_id: &str, applications_application_webhooks_webhook_id_custom_headers_post_request: crate::models::ApplicationsApplicationWebhooksWebhookIdCustomHeadersPostRequest) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdCustomHeadersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/custom-headers", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_webhooks_webhook_id_custom_headers_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdCustomHeadersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive application webhook
pub async fn applications_application_webhooks_webhook_id_delete(configuration: &configuration::Configuration, application: &str, webhook_id: &str) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update application webhook
pub async fn applications_application_webhooks_webhook_id_patch(configuration: &configuration::Configuration, application: &str, webhook_id: &str, applications_application_webhooks_webhook_id_patch_request: Option<crate::models::ApplicationsApplicationWebhooksWebhookIdPatchRequest>) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_webhooks_webhook_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore archived application webhook
pub async fn applications_application_webhooks_webhook_id_post(configuration: &configuration::Configuration, application: &str, webhook_id: &str) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_webhooks_webhook_id_signing_key_get(configuration: &configuration::Configuration, application: &str, webhook_id: &str) -> Result<String, Error<ApplicationsApplicationWebhooksWebhookIdSigningKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/signing-key", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSigningKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_application_webhooks_webhook_id_signing_key_regenerate_post(configuration: &configuration::Configuration, application: &str, webhook_id: &str) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdSigningKeyRegeneratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/signing-key/regenerate", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSigningKeyRegeneratePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get webhook subscriptions
pub async fn applications_application_webhooks_webhook_id_subscriptions_get(configuration: &configuration::Configuration, application: &str, webhook_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SubscriptionDto>, Error<ApplicationsApplicationWebhooksWebhookIdSubscriptionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/subscriptions", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSubscriptionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add webhook subscription
pub async fn applications_application_webhooks_webhook_id_subscriptions_post(configuration: &configuration::Configuration, application: &str, webhook_id: &str, applications_application_webhooks_webhook_id_subscriptions_post_request: crate::models::ApplicationsApplicationWebhooksWebhookIdSubscriptionsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::SubscriptionDto, Error<ApplicationsApplicationWebhooksWebhookIdSubscriptionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/subscriptions", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_webhooks_webhook_id_subscriptions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSubscriptionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete webhook subscription
pub async fn applications_application_webhooks_webhook_id_subscriptions_subscription_id_delete(configuration: &configuration::Configuration, application: &str, webhook_id: &str, subscription_id: &str) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id), subscriptionId=crate::apis::urlencode(subscription_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update webhook subscription
pub async fn applications_application_webhooks_webhook_id_subscriptions_subscription_id_patch(configuration: &configuration::Configuration, application: &str, webhook_id: &str, subscription_id: &str, dollar_fields: Option<&str>, applications_application_webhooks_webhook_id_subscriptions_subscription_id_patch_request: Option<crate::models::ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdPatchRequest>) -> Result<crate::models::SubscriptionDto, Error<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id), subscriptionId=crate::apis::urlencode(subscription_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_webhooks_webhook_id_subscriptions_subscription_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Ensures that all permissions required for this subscription are requested in the corresponding permission role
pub async fn applications_application_webhooks_webhook_id_subscriptions_subscription_id_request_missing_rights_post(configuration: &configuration::Configuration, application: &str, webhook_id: &str, subscription_id: &str) -> Result<(), Error<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdRequestMissingRightsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}/request-missing-rights", local_var_configuration.base_path, application=crate::apis::urlencode(application), webhookId=crate::apis::urlencode(webhook_id), subscriptionId=crate::apis::urlencode(subscription_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsApplicationWebhooksWebhookIdSubscriptionsSubscriptionIdRequestMissingRightsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List applications authorized in specified context
pub async fn applications_authorizations_authorized_applications_get(configuration: &configuration::Configuration, context_identifier: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EsApp>, Error<ApplicationsAuthorizationsAuthorizedApplicationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/authorizations/authorized-applications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("contextIdentifier", &context_identifier.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsAuthorizationsAuthorizedApplicationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide error message to display on application page in Space UI. Provide `null` message to remove it.
pub async fn applications_error_message_post(configuration: &configuration::Configuration, applications_error_message_post_request: Option<crate::models::ApplicationsErrorMessagePostRequest>) -> Result<(), Error<ApplicationsErrorMessagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/error-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_error_message_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsErrorMessagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn applications_paged_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, name: Option<&str>, owner: Option<Vec<String>>, with_archived: Option<bool>, with_managed: Option<bool>, ordering: Option<AppsOrdering>, dollar_fields: Option<&str>) -> Result<crate::models::ApplicationsPagedGet200Response, Error<ApplicationsPagedGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/paged", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = owner {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("owner".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("owner", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_managed {
        local_var_req_builder = local_var_req_builder.query(&[("withManaged", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsPagedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return all application parameters. Only accessible with an app token, not a user token.
pub async fn applications_parameters_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AppParameter>, Error<ApplicationsParametersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsParametersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove application parameter by key. Only accessible with an app token, not a user token.
pub async fn applications_parameters_key_delete(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<ApplicationsParametersKeyDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsParametersKeyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get application parameter by key. Only accessible with an app token, not a user token.
pub async fn applications_parameters_key_get(configuration: &configuration::Configuration, key: &str) -> Result<String, Error<ApplicationsParametersKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsParametersKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set application parameter by key. Only accessible with an app token, not a user token. There is a limit of 100 app parameters per app. The key cannot be longer than 64 characters. The value cannot be longer than 1000 characters.
pub async fn applications_parameters_key_patch(configuration: &configuration::Configuration, key: &str, applications_parameters_key_patch_request: crate::models::ApplicationsParametersKeyPatchRequest) -> Result<(), Error<ApplicationsParametersKeyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_parameters_key_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsParametersKeyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return all profile parameters, profile and application are derived from the access token. Only accessible with a user token, issued to an application.
pub async fn applications_parameters_profile_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AppParameter>, Error<ApplicationsParametersProfileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/profile", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsParametersProfileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove profile parameter by key, profile and application are derived from the access token. Only accessible with a user token, issued to an application.
pub async fn applications_parameters_profile_key_delete(configuration: &configuration::Configuration, key: &str) -> Result<(), Error<ApplicationsParametersProfileKeyDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/profile/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsParametersProfileKeyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get profile parameter by key, profile and application are derived from the access token. Only accessible with a user token, issued to an application.
pub async fn applications_parameters_profile_key_get(configuration: &configuration::Configuration, key: &str) -> Result<String, Error<ApplicationsParametersProfileKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/profile/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsParametersProfileKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set profile parameter by key, profile and application are derived from the access token. Only accessible with a user token, issued to an application. There is a limit of 100 app parameters per app per profile. The key cannot be longer than 64 characters. The value cannot be longer than 1000 characters.
pub async fn applications_parameters_profile_key_patch(configuration: &configuration::Configuration, key: &str, applications_parameters_key_patch_request: crate::models::ApplicationsParametersKeyPatchRequest) -> Result<(), Error<ApplicationsParametersProfileKeyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/parameters/profile/{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_parameters_key_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsParametersProfileKeyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new application. Marketplace application cannot be installed using this endpoint.  To create a multi-org application (and connect application server to the current Space instance), pass `connectToSpace = true`. Learn more about multi-org applications in the [documentation](https://www.jetbrains.com/help/space/distribute-your-application.html).
pub async fn applications_post(configuration: &configuration::Configuration, applications_post_request: crate::models::ApplicationsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::EsApp, Error<ApplicationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Application may periodically call this api method to notify Space that it is functioning properly. This is mandatory for applications that connect external issue trackers.
pub async fn applications_report_application_as_healthy_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApplicationsReportApplicationAsHealthyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/report-application-as-healthy", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsReportApplicationAsHealthyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set UI extensions supported by the calling application in specified context. Only the application itself can set its extensions.
pub async fn applications_ui_extensions_patch(configuration: &configuration::Configuration, applications_ui_extensions_patch_request: crate::models::ApplicationsUiExtensionsPatchRequest) -> Result<(), Error<ApplicationsUiExtensionsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/ui-extensions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_ui_extensions_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsUiExtensionsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update list of domains for unfurling by the application. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_domains_patch(configuration: &configuration::Configuration, applications_unfurls_domains_patch_request: crate::models::ApplicationsUnfurlsDomainsPatchRequest) -> Result<(), Error<ApplicationsUnfurlsDomainsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/domains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_unfurls_domains_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsDomainsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update list of external ID prefixes for unfurling by the application. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_patterns_patch(configuration: &configuration::Configuration, applications_unfurls_patterns_patch_request: crate::models::ApplicationsUnfurlsPatternsPatchRequest) -> Result<(), Error<ApplicationsUnfurlsPatternsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/patterns", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_unfurls_patterns_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsPatternsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide Space with unfurls content. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_queue_content_post(configuration: &configuration::Configuration, applications_unfurls_queue_content_post_request: crate::models::ApplicationsUnfurlsQueueContentPostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PostUnfurlContentResult>, Error<ApplicationsUnfurlsQueueContentPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/queue/content", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_unfurls_queue_content_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsQueueContentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get links for unfurling by the application. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_queue_get(configuration: &configuration::Configuration, batch_size: i32, from_etag: Option<i64>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ApplicationUnfurlQueueItem>, Error<ApplicationsUnfurlsQueueGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/queue", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from_etag {
        local_var_req_builder = local_var_req_builder.query(&[("fromEtag", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("batchSize", &batch_size.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsQueueGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request user to authenticate in external system to provide unfurls from it. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_queue_request_external_auth_post(configuration: &configuration::Configuration, applications_unfurls_queue_request_external_auth_post_request: crate::models::ApplicationsUnfurlsQueueRequestExternalAuthPostRequest) -> Result<(), Error<ApplicationsUnfurlsQueueRequestExternalAuthPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/queue/request-external-auth", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_unfurls_queue_request_external_auth_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsQueueRequestExternalAuthPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Clear all external system authentication requests for the specified user. Method is to be called by the application providing unfurls.
pub async fn applications_unfurls_queue_reset_external_auth_requests_post(configuration: &configuration::Configuration, applications_unfurls_queue_reset_external_auth_requests_post_request: crate::models::ApplicationsUnfurlsQueueResetExternalAuthRequestsPostRequest) -> Result<(), Error<ApplicationsUnfurlsQueueResetExternalAuthRequestsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/applications/unfurls/queue/reset-external-auth-requests", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_unfurls_queue_reset_external_auth_requests_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApplicationsUnfurlsQueueResetExternalAuthRequestsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset authentication configuration to default
pub async fn auth_modules_config_delete(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::AuthConfig, Error<AuthModulesConfigDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesConfigDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get authentication configuration
pub async fn auth_modules_config_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::AuthConfig, Error<AuthModulesConfigGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesConfigGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set authentication configuration
pub async fn auth_modules_config_put(configuration: &configuration::Configuration, auth_modules_config_put_request: Option<crate::models::AuthModulesConfigPutRequest>) -> Result<(), Error<AuthModulesConfigPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_config_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesConfigPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Automatically discovers the endpoints for the OpenID Connect provider via discovery document
pub async fn auth_modules_discover_oidc_get(configuration: &configuration::Configuration, discovery_endpoint: &str, dollar_fields: Option<&str>) -> Result<crate::models::OidcDiscovery, Error<AuthModulesDiscoverOidcGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/discover-oidc", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("discoveryEndpoint", &discovery_endpoint.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesDiscoverOidcGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all authentication modules
pub async fn auth_modules_get(configuration: &configuration::Configuration, with_disabled: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EsAuthModule>, Error<AuthModulesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_disabled {
        local_var_req_builder = local_var_req_builder.query(&[("withDisabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing authentication module
pub async fn auth_modules_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<AuthModulesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Change password for a given authentication module (id) and profile (identifier)
pub async fn auth_modules_id_logins_identifier_change_post(configuration: &configuration::Configuration, id: &str, identifier: &str, auth_modules_id_logins_identifier_change_post_request: crate::models::AuthModulesIdLoginsIdentifierChangePostRequest) -> Result<(), Error<AuthModulesIdLoginsIdentifierChangePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}/logins/{identifier}/change", local_var_configuration.base_path, id=crate::apis::urlencode(id), identifier=crate::apis::urlencode(identifier));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_id_logins_identifier_change_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesIdLoginsIdentifierChangePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Detach a profile login from an authentication module. The id parameter refers to the authentication module, the identifier parameter refers to the login.
pub async fn auth_modules_id_logins_identifier_delete(configuration: &configuration::Configuration, identifier: &str, id: &str) -> Result<(), Error<AuthModulesIdLoginsIdentifierDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}/logins/{identifier}", local_var_configuration.base_path, identifier=crate::apis::urlencode(identifier), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesIdLoginsIdentifierDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request a password reset for a given authentication module (id) and profile (identifier)
pub async fn auth_modules_id_logins_identifier_reset_post(configuration: &configuration::Configuration, id: &str, identifier: &str) -> Result<(), Error<AuthModulesIdLoginsIdentifierResetPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}/logins/{identifier}/reset", local_var_configuration.base_path, id=crate::apis::urlencode(id), identifier=crate::apis::urlencode(identifier));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesIdLoginsIdentifierResetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing authentication module. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn auth_modules_id_patch(configuration: &configuration::Configuration, id: &str, auth_modules_id_patch_request: Option<crate::models::AuthModulesIdPatchRequest>) -> Result<(), Error<AuthModulesIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn auth_modules_id_saml_metadata_post(configuration: &configuration::Configuration, id: &str, auth_modules_id_saml_metadata_post_request: crate::models::AuthModulesIdSamlMetadataPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::SamlMetadataResponse, Error<AuthModulesIdSamlMetadataPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/{id}/saml-metadata", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_id_saml_metadata_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesIdSamlMetadataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an existing authentication module
pub async fn auth_modules_keykey_get(configuration: &configuration::Configuration, key: &str, dollar_fields: Option<&str>) -> Result<crate::models::EsAuthModule, Error<AuthModulesKeykeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/key:{key}", local_var_configuration.base_path, key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesKeykeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new authentication module. Settings are specific to the type of authentication module being created.
pub async fn auth_modules_post(configuration: &configuration::Configuration, auth_modules_post_request: crate::models::AuthModulesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::EsAuthModule, Error<AuthModulesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Define the order of authentication modules. This affects the order of the federated authentication module buttons on the sign-in page.
pub async fn auth_modules_reorder_post(configuration: &configuration::Configuration, auth_modules_reorder_post_request: crate::models::AuthModulesReorderPostRequest) -> Result<(), Error<AuthModulesReorderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/reorder", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_reorder_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesReorderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// For a username/password combination, test built-in authentication with updated settings
pub async fn auth_modules_test_built_in_post(configuration: &configuration::Configuration, auth_modules_test_built_in_post_request: crate::models::AuthModulesTestBuiltInPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<AuthModulesTestBuiltInPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/test/built-in", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_test_built_in_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesTestBuiltInPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// For a username/password combination, test LDAP authentication with updated settings
pub async fn auth_modules_test_ldap_post(configuration: &configuration::Configuration, auth_modules_test_ldap_post_request: crate::models::AuthModulesTestLdapPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::EsDefaultProfileLoginDetails, Error<AuthModulesTestLdapPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/test/ldap", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&auth_modules_test_ldap_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesTestLdapPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Resets the counter that tracks failed login attempts for the account with the specified logins. The member who use these accounts are no longer blocked from attempting to log in to Space.
pub async fn auth_modules_throttled_logins_delete(configuration: &configuration::Configuration, logins: Vec<String>) -> Result<(), Error<AuthModulesThrottledLoginsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/throttled-logins", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&logins.into_iter().map(|p| ("logins".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("logins", &logins.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesThrottledLoginsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns logins that are currently subjected to rate limits when logging in to Space
pub async fn auth_modules_throttled_logins_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, login: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::AuthModulesThrottledLoginsGet200Response, Error<AuthModulesThrottledLoginsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/throttled-logins", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = login {
        local_var_req_builder = local_var_req_builder.query(&[("login", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesThrottledLoginsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Resets date and time until which the organization are throttled
pub async fn auth_modules_throttled_logins_org_status_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<AuthModulesThrottledLoginsOrgStatusDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/throttled-logins/org-status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AuthModulesThrottledLoginsOrgStatusDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns date and time until which the organization are throttled
pub async fn auth_modules_throttled_logins_org_status_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::OrgThrottlingStatus, Error<AuthModulesThrottledLoginsOrgStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/throttled-logins/org-status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesThrottledLoginsOrgStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of authentication module usage count
pub async fn auth_modules_usages_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AuthModuleUsage>, Error<AuthModulesUsagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/auth-modules/usages", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AuthModulesUsagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn billing_admin_features_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::TierFeatureLimits, Error<BillingAdminFeaturesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/features", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BillingAdminFeaturesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn billing_admin_overdrafts_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::Overdrafts, Error<BillingAdminOverdraftsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/overdrafts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BillingAdminOverdraftsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn billing_admin_overdrafts_put(configuration: &configuration::Configuration, billing_admin_overdrafts_put_request: crate::models::BillingAdminOverdraftsPutRequest) -> Result<(), Error<BillingAdminOverdraftsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/overdrafts", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&billing_admin_overdrafts_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<BillingAdminOverdraftsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a billing report for the given billing period
pub async fn billing_admin_reports_billing_period_get(configuration: &configuration::Configuration, billing_period: &str, dollar_fields: Option<&str>) -> Result<crate::models::BillingReport, Error<BillingAdminReportsBillingPeriodGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/reports/{billingPeriod}", local_var_configuration.base_path, billingPeriod=crate::apis::urlencode(billing_period));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BillingAdminReportsBillingPeriodGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a billing report for today
pub async fn billing_admin_reports_today_get(configuration: &configuration::Configuration, date: &str, dollar_fields: Option<&str>) -> Result<crate::models::TodayBillingReport, Error<BillingAdminReportsTodayGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/reports/today", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("date", &date.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BillingAdminReportsTodayGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn billing_admin_trial_put(configuration: &configuration::Configuration, billing_admin_trial_put_request: crate::models::BillingAdminTrialPutRequest) -> Result<(), Error<BillingAdminTrialPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/billing-admin/trial", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&billing_admin_trial_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<BillingAdminTrialPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_aliasalias_get(configuration: &configuration::Configuration, alias: &str, dollar_fields: Option<&str>) -> Result<crate::models::ArticleRecord, Error<BlogAliasaliasGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/alias:{alias}", local_var_configuration.base_path, alias=crate::apis::urlencode(alias));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogAliasaliasGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_external_idid_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::ArticleRecord, Error<BlogExternalIdidGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/external-id:{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogExternalIdidGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, term: Option<&str>, date_from: Option<String>, date_to: Option<String>, author_id: Option<&str>, team_id: Option<&str>, location_id: Option<&str>, for_profile: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::BlogGet200Response, Error<BlogGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = term {
        local_var_req_builder = local_var_req_builder.query(&[("term", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_from {
        local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_to {
        local_var_req_builder = local_var_req_builder.query(&[("dateTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = author_id {
        local_var_req_builder = local_var_req_builder.query(&[("authorId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_id {
        local_var_req_builder = local_var_req_builder.query(&[("locationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = for_profile {
        local_var_req_builder = local_var_req_builder.query(&[("forProfile", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<BlogIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<BlogIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::ArticleRecord, Error<BlogIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, blog_id_patch_request: Option<crate::models::BlogIdPatchRequest>) -> Result<crate::models::ArticleRecord, Error<BlogIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&blog_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_import_post(configuration: &configuration::Configuration, blog_import_post_request: crate::models::BlogImportPostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ArticleImportResult>, Error<BlogImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&blog_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_post(configuration: &configuration::Configuration, blog_post_request: crate::models::BlogPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ArticleRecord, Error<BlogPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&blog_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn blog_stats_get(configuration: &configuration::Configuration, date_from: Option<String>, date_to: Option<String>, author_id: Option<&str>, team_id: Option<&str>, location_id: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::BgStats, Error<BlogStatsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/blog/stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date_from {
        local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = date_to {
        local_var_req_builder = local_var_req_builder.query(&[("dateTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = author_id {
        local_var_req_builder = local_var_req_builder.query(&[("authorId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_id {
        local_var_req_builder = local_var_req_builder.query(&[("locationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BlogStatsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search absences. Parameters are applied as 'AND' filters.
pub async fn calendars_absence_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AbsenceEvent>, Error<CalendarsAbsenceEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/absence-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsAbsenceEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search birthdays. Parameters are applied as 'AND' filters.
pub async fn calendars_birthday_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BirthdayEvent>, Error<CalendarsBirthdayEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/birthday-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsBirthdayEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search birthdays in a specific time period for starred profiles.
pub async fn calendars_birthday_events_starred_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BirthdayEvent>, Error<CalendarsBirthdayEventsStarredGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/birthday-events/starred", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsBirthdayEventsStarredGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update RSVP / calendar event participation status for a calendar event attached to an article
pub async fn calendars_event_participations_id_patch(configuration: &configuration::Configuration, id: &str, calendars_event_participations_id_patch_request: crate::models::CalendarsEventParticipationsIdPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::MeetingRecord, Error<CalendarsEventParticipationsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/event-participations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_event_participations_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsEventParticipationsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get calendar events attached to an article in a specific time period
pub async fn calendars_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MeetingRecord>, Error<CalendarsEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a calendar event attached to an article
pub async fn calendars_events_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::MeetingRecord, Error<CalendarsEventsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/events/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsEventsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search holidays. Parameters are applied as 'AND' filters.
pub async fn calendars_holidays_get(configuration: &configuration::Configuration, start_date: &str, end_date: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, working_days: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::HolidaysEvent>, Error<CalendarsHolidaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("startDate", &start_date.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("endDate", &end_date.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = working_days {
        local_var_req_builder = local_var_req_builder.query(&[("workingDays", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsHolidaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search meetings by name, location, time period and other parameters. Parameters are applied as 'AND' filters while values in lists of locations, profiles and teams have 'OR' semantics.
pub async fn calendars_meetings_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, summary_query: Option<&str>, locations_query: Option<Vec<String>>, starting_after: Option<String>, ending_after: Option<String>, ending_before: Option<String>, starting_before: Option<String>, profiles: Option<Vec<String>>, teams: Option<Vec<String>>, organizer: Option<&str>, include_private: Option<bool>, include_archived: Option<bool>, include_meeting_instances: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::CalendarsMeetingsGet200Response, Error<CalendarsMeetingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = summary_query {
        local_var_req_builder = local_var_req_builder.query(&[("summaryQuery", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = locations_query {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("locationsQuery".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("locationsQuery", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = starting_after {
        local_var_req_builder = local_var_req_builder.query(&[("startingAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ending_after {
        local_var_req_builder = local_var_req_builder.query(&[("endingAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ending_before {
        local_var_req_builder = local_var_req_builder.query(&[("endingBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starting_before {
        local_var_req_builder = local_var_req_builder.query(&[("startingBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profiles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("profiles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = teams {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("teams", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = organizer {
        local_var_req_builder = local_var_req_builder.query(&[("organizer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_private {
        local_var_req_builder = local_var_req_builder.query(&[("includePrivate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_archived {
        local_var_req_builder = local_var_req_builder.query(&[("includeArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_meeting_instances {
        local_var_req_builder = local_var_req_builder.query(&[("includeMeetingInstances", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_id_conference_rooms_delete(configuration: &configuration::Configuration, id: &str, room_id: &str, date_time: String) -> Result<(), Error<CalendarsMeetingsIdConferenceRoomsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}/conference-rooms", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("roomId", &room_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTime", &date_time.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdConferenceRoomsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_id_conference_rooms_post(configuration: &configuration::Configuration, id: &str, calendars_meetings_id_conference_rooms_post_request: crate::models::CalendarsMeetingsIdConferenceRoomsPostRequest) -> Result<(), Error<CalendarsMeetingsIdConferenceRoomsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}/conference-rooms", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_meetings_id_conference_rooms_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdConferenceRoomsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_id_delete(configuration: &configuration::Configuration, id: &str, target_date: Option<String>, modification_kind: Option<RecurrentModification>, dollar_fields: Option<&str>) -> Result<crate::models::DtoMeeting, Error<CalendarsMeetingsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = target_date {
        local_var_req_builder = local_var_req_builder.query(&[("targetDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = modification_kind {
        local_var_req_builder = local_var_req_builder.query(&[("modificationKind", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::DtoMeeting, Error<CalendarsMeetingsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update profile participation status for a meeting
pub async fn calendars_meetings_id_participation_status_patch(configuration: &configuration::Configuration, id: &str, calendars_meetings_id_participation_status_patch_request: crate::models::CalendarsMeetingsIdParticipationStatusPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DtoMeeting, Error<CalendarsMeetingsIdParticipationStatusPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}/participation-status", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_meetings_id_participation_status_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdParticipationStatusPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Patch a meeting. Only not-null parameters and not empty diffs will be applied.
pub async fn calendars_meetings_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, calendars_meetings_id_patch_request: Option<crate::models::CalendarsMeetingsIdPatchRequest>) -> Result<crate::models::DtoMeeting, Error<CalendarsMeetingsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_meetings_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search for the next meeting occurrence that starts after the provided time point or after the current time if it is not specified
pub async fn calendars_meetings_next_occurrence_get(configuration: &configuration::Configuration, meeting_id: &str, since: Option<String>, dollar_fields: Option<&str>) -> Result<crate::models::MeetingOccurrenceTime, Error<CalendarsMeetingsNextOccurrenceGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/next-occurrence", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("meetingId", &meeting_id.to_string())]);
    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsNextOccurrenceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search for occurrences of a meeting that start in the provided time interval. Interval limits are inclusive, response is limited by the first 1_000 results by default (per meeting).
pub async fn calendars_meetings_occurrences_by_meeting_get(configuration: &configuration::Configuration, meeting_ids: Vec<String>, since: String, until: String, limit: Option<i32>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MeetingWithOccurrenceTime>, Error<CalendarsMeetingsOccurrencesByMeetingGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/occurrences-by-meeting", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&meeting_ids.into_iter().map(|p| ("meetingIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("meetingIds", &meeting_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    local_var_req_builder = local_var_req_builder.query(&[("since", &since.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("until", &until.to_string())]);
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsOccurrencesByMeetingGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search for occurrences of a meeting that start in the provided time interval. Interval limits are inclusive, response is limited by the first 1_000 results by default.
pub async fn calendars_meetings_occurrences_get(configuration: &configuration::Configuration, meeting_id: &str, since: String, until: String, limit: Option<i32>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MeetingOccurrenceTime>, Error<CalendarsMeetingsOccurrencesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/occurrences", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("meetingId", &meeting_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("since", &since.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("until", &until.to_string())]);
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsOccurrencesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_participation_statuses_external_get(configuration: &configuration::Configuration, id: &str, emails: Vec<String>) -> Result<Vec<crate::models::EventParticipationStatus>, Error<CalendarsMeetingsParticipationStatusesExternalGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/participation-statuses-external", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("id", &id.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&emails.into_iter().map(|p| ("emails".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("emails", &emails.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsParticipationStatusesExternalGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_participation_statuses_get(configuration: &configuration::Configuration, id: &str, profile_ids: Vec<String>) -> Result<Vec<crate::models::EventParticipationStatus>, Error<CalendarsMeetingsParticipationStatusesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/participation-statuses", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("id", &id.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&profile_ids.into_iter().map(|p| ("profileIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("profileIds", &profile_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsParticipationStatusesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a meeting
pub async fn calendars_meetings_post(configuration: &configuration::Configuration, calendars_meetings_post_request: crate::models::CalendarsMeetingsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DtoMeeting, Error<CalendarsMeetingsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_meetings_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_profile_participation_get(configuration: &configuration::Configuration, profile_id: &str, events: Vec<String>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CalendarsMeetingsProfileParticipationGet200ResponseInner>, Error<CalendarsMeetingsProfileParticipationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/profile-participation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profileId", &profile_id.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&events.into_iter().map(|p| ("events".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("events", &events.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsProfileParticipationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calendars_meetings_profile_participation_records_get(configuration: &configuration::Configuration, profile_id: &str, events: Vec<String>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::DtoMeetingRsvp>, Error<CalendarsMeetingsProfileParticipationRecordsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/meetings/profile-participation-records", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profileId", &profile_id.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&events.into_iter().map(|p| ("events".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("events", &events.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMeetingsProfileParticipationRecordsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search membership events. Parameters are applied as 'AND' filters.
pub async fn calendars_membership_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MembershipEvent>, Error<CalendarsMembershipEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/membership-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsMembershipEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search non-working day events. Parameters are applied as 'AND' filters.
pub async fn calendars_non_working_days_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, member: Option<&str>, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::NonWorkingDaysEvent>, Error<CalendarsNonWorkingDaysEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calendars/non-working-days-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = member {
        local_var_req_builder = local_var_req_builder.query(&[("member", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CalendarsNonWorkingDaysEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn calls_post(configuration: &configuration::Configuration, calls_post_request: crate::models::CallsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Room, Error<CallsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/calls", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calls_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CallsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_all_channels_get(configuration: &configuration::Configuration, query: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, quick_filter: Option<AllChannelsFilter>, sort_column: Option<AllChannelsSortColumn>, sort_order: Option<ColumnSortOrder>, public_only: Option<bool>, with_archived: Option<bool>, subscriber: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsAllChannelsGet200Response, Error<ChatsChannelsAllChannelsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/all-channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quick_filter {
        local_var_req_builder = local_var_req_builder.query(&[("quickFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_column {
        local_var_req_builder = local_var_req_builder.query(&[("sortColumn", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = public_only {
        local_var_req_builder = local_var_req_builder.query(&[("publicOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = subscriber {
        local_var_req_builder = local_var_req_builder.query(&[("subscriber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsAllChannelsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_administrator_get(configuration: &configuration::Configuration, channel: &str, dollar_fields: Option<&str>) -> Result<crate::models::CPrincipal, Error<ChatsChannelsChannelAdministratorGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/administrator", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAdministratorGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_administrator_patch(configuration: &configuration::Configuration, channel: &str, chats_channels_channel_administrator_patch_request: crate::models::ChatsChannelsChannelAdministratorPatchRequest) -> Result<(), Error<ChatsChannelsChannelAdministratorPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/administrator", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_administrator_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAdministratorPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive a channel and reject new messages being added. It is still possible to view messages from an archived channel. It is possible to restore the channel later.
pub async fn chats_channels_channel_archive_delete(configuration: &configuration::Configuration, channel: &str) -> Result<(), Error<ChatsChannelsChannelArchiveDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/archive", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelArchiveDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_attachments_files_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelAttachmentsGet200Response, Error<ChatsChannelsChannelAttachmentsFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/attachments/files", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAttachmentsFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_attachments_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelAttachmentsGet200Response, Error<ChatsChannelsChannelAttachmentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/attachments", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAttachmentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_attachments_images_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelAttachmentsGet200Response, Error<ChatsChannelsChannelAttachmentsImagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/attachments/images", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAttachmentsImagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_attachments_links_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelAttachmentsGet200Response, Error<ChatsChannelsChannelAttachmentsLinksGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/attachments/links", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAttachmentsLinksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_attachments_videos_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelAttachmentsGet200Response, Error<ChatsChannelsChannelAttachmentsVideosGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/attachments/videos", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelAttachmentsVideosGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a channel. No one will be able to view this channel or its threads. This action cannot be undone.
pub async fn chats_channels_channel_delete(configuration: &configuration::Configuration, channel: &str) -> Result<(), Error<ChatsChannelsChannelDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_description_patch(configuration: &configuration::Configuration, channel: &str, chats_channels_channel_description_patch_request: crate::models::ChatsChannelsChannelDescriptionPatchRequest) -> Result<(), Error<ChatsChannelsChannelDescriptionPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/description", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_description_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelDescriptionPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_get(configuration: &configuration::Configuration, channel: &str, dollar_fields: Option<&str>) -> Result<crate::models::M2ChannelRecord, Error<ChatsChannelsChannelGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_icon_patch(configuration: &configuration::Configuration, channel: &str, chats_channels_channel_icon_patch_request: Option<crate::models::ChatsChannelsChannelIconPatchRequest>) -> Result<(), Error<ChatsChannelsChannelIconPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/icon", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_icon_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelIconPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_name_patch(configuration: &configuration::Configuration, channel: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest) -> Result<(), Error<ChatsChannelsChannelNamePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/name", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelNamePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore an archived channel and allow new messages to be added again.
pub async fn chats_channels_channel_restore_archived_post(configuration: &configuration::Configuration, channel: &str) -> Result<(), Error<ChatsChannelsChannelRestoreArchivedPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/restore-archived", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelRestoreArchivedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_teams_delete(configuration: &configuration::Configuration, channel: &str, teams: Vec<String>) -> Result<(), Error<ChatsChannelsChannelSubscribersTeamsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/teams", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&teams.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("teams", &teams.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersTeamsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_teams_get(configuration: &configuration::Configuration, channel: &str, query: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersTeamsGet200Response, Error<ChatsChannelsChannelSubscribersTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/teams", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_teams_post(configuration: &configuration::Configuration, channel: &str, chats_channels_channel_subscribers_teams_post_request: crate::models::ChatsChannelsChannelSubscribersTeamsPostRequest) -> Result<(), Error<ChatsChannelsChannelSubscribersTeamsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/teams", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_subscribers_teams_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersTeamsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_users_delete(configuration: &configuration::Configuration, channel: &str, profiles: Vec<String>) -> Result<(), Error<ChatsChannelsChannelSubscribersUsersDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/users", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&profiles.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("profiles", &profiles.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersUsersDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_users_get(configuration: &configuration::Configuration, channel: &str, query: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<ChatsChannelsChannelSubscribersUsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/users", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersUsersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_channel_subscribers_users_post(configuration: &configuration::Configuration, channel: &str, chats_channels_channel_subscribers_users_post_request: crate::models::ChatsChannelsChannelSubscribersUsersPostRequest) -> Result<(), Error<ChatsChannelsChannelSubscribersUsersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/{channel}/subscribers/users", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_subscribers_users_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsChannelSubscribersUsersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_conversations_channel_convert_post(configuration: &configuration::Configuration, channel: &str, chats_channels_conversations_channel_convert_post_request: crate::models::ChatsChannelsConversationsChannelConvertPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::M2ChannelRecord, Error<ChatsChannelsConversationsChannelConvertPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/conversations/{channel}/convert", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_conversations_channel_convert_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsConversationsChannelConvertPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_conversations_channel_subject_patch(configuration: &configuration::Configuration, channel: &str, chats_channels_conversations_channel_subject_patch_request: crate::models::ChatsChannelsConversationsChannelSubjectPatchRequest) -> Result<(), Error<ChatsChannelsConversationsChannelSubjectPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/conversations/{channel}/subject", local_var_configuration.base_path, channel=crate::apis::urlencode(channel));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_conversations_channel_subject_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsChannelsConversationsChannelSubjectPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_conversations_post(configuration: &configuration::Configuration, chats_channels_conversations_post_request: crate::models::ChatsChannelsConversationsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::M2ChannelRecord, Error<ChatsChannelsConversationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/conversations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_conversations_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsConversationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create or get a direct messages channel with a profile
pub async fn chats_channels_dm_post(configuration: &configuration::Configuration, chats_channels_dm_post_request: crate::models::ChatsChannelsDmPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::M2ChannelRecord, Error<ChatsChannelsDmPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/dm", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_dm_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsDmPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check whether a channel name is available. Returns true when the channel name can be used to create a new channel, false otherwise.
pub async fn chats_channels_is_name_free_post(configuration: &configuration::Configuration, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest) -> Result<bool, Error<ChatsChannelsIsNameFreePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels/is-name-free", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsIsNameFreePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_channels_post(configuration: &configuration::Configuration, chats_channels_post_request: crate::models::ChatsChannelsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::M2ChannelRecord, Error<ChatsChannelsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsChannelsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a message from a channel.
pub async fn chats_messages_delete_message_post(configuration: &configuration::Configuration, chats_messages_delete_message_post_request: crate::models::ChatsMessagesDeleteMessagePostRequest) -> Result<(), Error<ChatsMessagesDeleteMessagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/delete-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_delete_message_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsMessagesDeleteMessagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit an existing message. Message content can be a string, or a block with one or several sections of information.
pub async fn chats_messages_edit_message_post(configuration: &configuration::Configuration, chats_messages_edit_message_post_request: crate::models::ChatsMessagesEditMessagePostRequest) -> Result<(), Error<ChatsMessagesEditMessagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/edit-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_edit_message_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsMessagesEditMessagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a batch of messages from a channel. Messages are divided into batches by providing `sorting`, `startFromDate` and `batchSize` parameters. If the retrieved number of messages is less than `batchSize`, there are currently no more messages to return. Return data also contains next value for `startFromDate` as well as the `orgLimitReached` flag indicating whether part of messages could not be retrieved because of organization plan limitation.
pub async fn chats_messages_get(configuration: &configuration::Configuration, channel: &str, sorting: MessagesSorting, batch_size: i32, start_from_date: Option<String>, dollar_fields: Option<&str>) -> Result<crate::models::GetMessagesResponse, Error<ChatsMessagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sorting", &sorting.to_string())]);
    if let Some(ref local_var_str) = start_from_date {
        local_var_req_builder = local_var_req_builder.query(&[("startFromDate", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("batchSize", &batch_size.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This API method is intended to be used only by applications. The `createdAtUtc` and `editedAtUtc` parameters are Unix epoch timestamps in *milliseconds*.
pub async fn chats_messages_import_post(configuration: &configuration::Configuration, chats_messages_import_post_request: crate::models::ChatsMessagesImportPostRequest) -> Result<(), Error<ChatsMessagesImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsMessagesImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_message_get(configuration: &configuration::Configuration, message: &str, channel: &str, dollar_fields: Option<&str>) -> Result<crate::models::ChannelItemRecord, Error<ChatsMessagesMessageGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/{message}", local_var_configuration.base_path, message=crate::apis::urlencode(message));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesMessageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_pin_patch(configuration: &configuration::Configuration, chats_messages_pin_patch_request: crate::models::ChatsMessagesPinPatchRequest) -> Result<(), Error<ChatsMessagesPinPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/pin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_pin_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsMessagesPinPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_pinned_messages_get(configuration: &configuration::Configuration, channel: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsMessagesPinnedMessagesGet200Response, Error<ChatsMessagesPinnedMessagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/pinned-messages", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesPinnedMessagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Send a message to a channel, thread, member, issue, code review, etc. Message content can be a string, or a block with one or several sections of information.
pub async fn chats_messages_send_message_post(configuration: &configuration::Configuration, chats_messages_send_message_post_request: crate::models::ChatsMessagesSendMessagePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ChannelItemRecord, Error<ChatsMessagesSendMessagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/send-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_send_message_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesSendMessagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_send_post(configuration: &configuration::Configuration, chats_messages_send_post_request: crate::models::ChatsMessagesSendPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ChannelItemRecord, Error<ChatsMessagesSendPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/send", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_send_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesSendPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_sync_batch_current_etag_get(configuration: &configuration::Configuration, channel: &str) -> Result<String, Error<ChatsMessagesSyncBatchCurrentEtagGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/sync-batch/current-etag", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesSyncBatchCurrentEtagGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_sync_batch_get(configuration: &configuration::Configuration, batch_info: &str, channel: &str, dollar_fields: Option<&str>) -> Result<crate::models::ChatsMessagesSyncBatchGet200Response, Error<ChatsMessagesSyncBatchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/sync-batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("batchInfo", &batch_info.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChatsMessagesSyncBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn chats_messages_unpin_patch(configuration: &configuration::Configuration, chats_messages_pin_patch_request: crate::models::ChatsMessagesPinPatchRequest) -> Result<(), Error<ChatsMessagesUnpinPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/chats/messages/unpin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_messages_pin_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChatsMessagesUnpinPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete plan item and its children from a checklist
pub async fn checklists_checklist_items_plan_item_delete(configuration: &configuration::Configuration, checklist: &str, plan_item: &str) -> Result<(), Error<ChecklistsChecklistItemsPlanItemDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/checklists/{checklist}/items/{planItem}", local_var_configuration.base_path, checklist=crate::apis::urlencode(checklist), planItem=crate::apis::urlencode(plan_item));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ChecklistsChecklistItemsPlanItemDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get plan item by its identifier in a checklist
pub async fn checklists_checklist_items_plan_item_get(configuration: &configuration::Configuration, checklist: &str, plan_item: &str, dollar_fields: Option<&str>) -> Result<crate::models::PlanItem, Error<ChecklistsChecklistItemsPlanItemGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/checklists/{checklist}/items/{planItem}", local_var_configuration.base_path, checklist=crate::apis::urlencode(checklist), planItem=crate::apis::urlencode(plan_item));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChecklistsChecklistItemsPlanItemGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Move plan item in a checklist
pub async fn checklists_checklist_items_plan_item_move_post(configuration: &configuration::Configuration, checklist: &str, plan_item: &str, checklists_checklist_items_plan_item_move_post_request: crate::models::ChecklistsChecklistItemsPlanItemMovePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PlanItem, Error<ChecklistsChecklistItemsPlanItemMovePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/checklists/{checklist}/items/{planItem}/move", local_var_configuration.base_path, checklist=crate::apis::urlencode(checklist), planItem=crate::apis::urlencode(plan_item));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&checklists_checklist_items_plan_item_move_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChecklistsChecklistItemsPlanItemMovePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update plan item in a checklist
pub async fn checklists_checklist_items_plan_item_patch(configuration: &configuration::Configuration, checklist: &str, plan_item: &str, dollar_fields: Option<&str>, checklists_checklist_items_plan_item_patch_request: Option<crate::models::ChecklistsChecklistItemsPlanItemPatchRequest>) -> Result<crate::models::PlanItem, Error<ChecklistsChecklistItemsPlanItemPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/checklists/{checklist}/items/{planItem}", local_var_configuration.base_path, checklist=crate::apis::urlencode(checklist), planItem=crate::apis::urlencode(plan_item));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&checklists_checklist_items_plan_item_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChecklistsChecklistItemsPlanItemPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create plan item as the last element of the top level in a checklist if parent plan item is null, or as the last child if parent plan item is provided.
pub async fn checklists_checklist_items_post(configuration: &configuration::Configuration, checklist: &str, checklists_checklist_items_post_request: crate::models::ChecklistsChecklistItemsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PlanItem, Error<ChecklistsChecklistItemsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/checklists/{checklist}/items", local_var_configuration.base_path, checklist=crate::apis::urlencode(checklist));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&checklists_checklist_items_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ChecklistsChecklistItemsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all types that support custom fields
pub async fn custom_fields_extended_types_get(configuration: &configuration::Configuration, scope: Option<ExtendedTypeScopeType>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ExtendedType>, Error<CustomFieldsExtendedTypesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/extended-types", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsExtendedTypesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all custom field values for a type. Optionally, extendedEntityIds can be used to get data for one or more entity IDs.
pub async fn custom_fields_type_key_all_values_get(configuration: &configuration::Configuration, type_key: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, extended_entity_ids: Option<Vec<String>>, scope: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldsTypeKeyAllValuesGet200Response, Error<CustomFieldsTypeKeyAllValuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/all-values", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = extended_entity_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("extendedEntityIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("extendedEntityIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyAllValuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get custom field value for a type and entity ID
pub async fn custom_fields_type_key_entity_id_values_get(configuration: &configuration::Configuration, type_key: &str, entity_id: &str, scope: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldsRecord, Error<CustomFieldsTypeKeyEntityIdValuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/{entityId}/values", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), entityId=crate::apis::urlencode(entity_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyEntityIdValuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update custom field value(s) for a type and entity ID
pub async fn custom_fields_type_key_entity_id_values_patch(configuration: &configuration::Configuration, entity_id: &str, type_key: &str, custom_fields_type_key_entity_id_values_patch_request: crate::models::CustomFieldsTypeKeyEntityIdValuesPatchRequest) -> Result<(), Error<CustomFieldsTypeKeyEntityIdValuesPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/{entityId}/values", local_var_configuration.base_path, entityId=crate::apis::urlencode(entity_id), typeKey=crate::apis::urlencode(type_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_entity_id_values_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyEntityIdValuesPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a page of options for custom field of `Select from options` type with `Open-ended` flag set
pub async fn custom_fields_type_key_enum_values_custom_field_id_get(configuration: &configuration::Configuration, type_key: &str, custom_field_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, ordering: Option<EnumValueOrdering>, count_records: Option<bool>, added_by_profile_id: Option<&str>, scope: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldsTypeKeyEnumValuesCustomFieldIdGet200Response, Error<CustomFieldsTypeKeyEnumValuesCustomFieldIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/enum-values/{customFieldId}", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), customFieldId=crate::apis::urlencode(custom_field_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count_records {
        local_var_req_builder = local_var_req_builder.query(&[("countRecords", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = added_by_profile_id {
        local_var_req_builder = local_var_req_builder.query(&[("addedByProfileId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyEnumValuesCustomFieldIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add new option to custom field of `Select from options` type. Options can only be added via this API call if custom field has the `Open-ended` flag set. Returns saved records.
pub async fn custom_fields_type_key_enum_values_custom_field_id_post(configuration: &configuration::Configuration, type_key: &str, custom_field_id: &str, custom_fields_type_key_enum_values_custom_field_id_post_request: crate::models::CustomFieldsTypeKeyEnumValuesCustomFieldIdPostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EnumValueData>, Error<CustomFieldsTypeKeyEnumValuesCustomFieldIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/enum-values/{customFieldId}", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), customFieldId=crate::apis::urlencode(custom_field_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_enum_values_custom_field_id_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyEnumValuesCustomFieldIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get custom fields for a type
pub async fn custom_fields_type_key_fields_get(configuration: &configuration::Configuration, type_key: &str, with_archived: Option<bool>, scope: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CustomField>, Error<CustomFieldsTypeKeyFieldsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive a custom field for a type
pub async fn custom_fields_type_key_fields_id_archive_post(configuration: &configuration::Configuration, type_key: &str, id: &str, custom_fields_type_key_fields_id_archive_post_request: crate::models::CustomFieldsTypeKeyFieldsIdArchivePostRequest) -> Result<(), Error<CustomFieldsTypeKeyFieldsIdArchivePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/{id}/archive", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_fields_id_archive_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsIdArchivePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove custom field for a type
pub async fn custom_fields_type_key_fields_id_delete(configuration: &configuration::Configuration, type_key: &str, id: &str, scope: &str) -> Result<(), Error<CustomFieldsTypeKeyFieldsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/{id}", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("scope", &scope.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_type_key_fields_id_filter_values_get(configuration: &configuration::Configuration, type_key: &str, id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, scope: Option<&str>, calculate_total: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldsTypeKeyFieldsIdFilterValuesGet200Response, Error<CustomFieldsTypeKeyFieldsIdFilterValuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/{id}/filter-values", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = calculate_total {
        local_var_req_builder = local_var_req_builder.query(&[("calculateTotal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsIdFilterValuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update custom field for a type. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn custom_fields_type_key_fields_id_patch(configuration: &configuration::Configuration, type_key: &str, id: &str, custom_fields_type_key_fields_id_patch_request: crate::models::CustomFieldsTypeKeyFieldsIdPatchRequest) -> Result<(), Error<CustomFieldsTypeKeyFieldsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/{id}", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_fields_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore custom field for a type
pub async fn custom_fields_type_key_fields_id_restore_post(configuration: &configuration::Configuration, type_key: &str, id: &str, custom_fields_type_key_fields_id_archive_post_request: crate::models::CustomFieldsTypeKeyFieldsIdArchivePostRequest) -> Result<(), Error<CustomFieldsTypeKeyFieldsIdRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/{id}/restore", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_fields_id_archive_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsIdRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create custom field for a type
pub async fn custom_fields_type_key_fields_post(configuration: &configuration::Configuration, type_key: &str, custom_fields_type_key_fields_post_request: crate::models::CustomFieldsTypeKeyFieldsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CustomField, Error<CustomFieldsTypeKeyFieldsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_fields_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Re-order custom fields. Pass IDs of the custom fields in the order you wish the custom fields to be.
pub async fn custom_fields_type_key_fields_reorder_post(configuration: &configuration::Configuration, type_key: &str, custom_fields_type_key_fields_reorder_post_request: crate::models::CustomFieldsTypeKeyFieldsReorderPostRequest) -> Result<(), Error<CustomFieldsTypeKeyFieldsReorderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields/{typeKey}/fields/reorder", local_var_configuration.base_path, typeKey=crate::apis::urlencode(type_key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_type_key_fields_reorder_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsTypeKeyFieldsReorderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_archive_post(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldArchivePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/archive", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldArchivePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_delete(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_enum_values_bulk_update_post(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, custom_fields_v2_entity_type_fields_custom_field_enum_values_bulk_update_post_request: crate::models::CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesBulkUpdatePostRequest) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesBulkUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/enum-values/bulk-update", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_custom_field_enum_values_bulk_update_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesBulkUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_enum_values_enum_value_to_remove_delete(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, enum_value_to_remove: &str) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesEnumValueToRemoveDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/enum-values/{enumValueToRemove}", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field), enumValueToRemove=crate::apis::urlencode(enum_value_to_remove));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesEnumValueToRemoveDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_enum_values_get(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, query: Option<&str>, ordering: Option<EnumValueOrdering>, added_by_profile_id: Option<&str>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesGet200Response, Error<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/enum-values", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ordering {
        local_var_req_builder = local_var_req_builder.query(&[("ordering", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = added_by_profile_id {
        local_var_req_builder = local_var_req_builder.query(&[("addedByProfileId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_enum_values_patch(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, custom_fields_v2_entity_type_fields_custom_field_enum_values_patch_request: crate::models::CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPatchRequest) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/enum-values", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_custom_field_enum_values_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_enum_values_post(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, custom_fields_v2_entity_type_fields_custom_field_enum_values_post_request: crate::models::CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CfEnumValue, Error<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/enum-values", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_custom_field_enum_values_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldEnumValuesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get configured custom field
pub async fn custom_fields_v2_entity_type_fields_custom_field_get(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldData, Error<CustomFieldsV2EntityTypeFieldsCustomFieldGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_patch(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str, custom_fields_v2_entity_type_fields_custom_field_patch_request: Option<crate::models::CustomFieldsV2EntityTypeFieldsCustomFieldPatchRequest>) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_custom_field_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_custom_field_restore_post(configuration: &configuration::Configuration, entity_type: &str, custom_field: &str) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsCustomFieldRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/{customField}/restore", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsCustomFieldRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all configured custom fields for an entity type
pub async fn custom_fields_v2_entity_type_fields_get(configuration: &configuration::Configuration, entity_type: &str, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CustomFieldData>, Error<CustomFieldsV2EntityTypeFieldsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_entity_type_fields_post(configuration: &configuration::Configuration, entity_type: &str, custom_fields_v2_entity_type_fields_post_request: crate::models::CustomFieldsV2EntityTypeFieldsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldData, Error<CustomFieldsV2EntityTypeFieldsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Re-order custom fields. Pass identifiers of the custom fields in the order you wish the custom fields to be.
pub async fn custom_fields_v2_entity_type_fields_reorder_post(configuration: &configuration::Configuration, entity_type: &str, custom_fields_v2_entity_type_fields_reorder_post_request: crate::models::CustomFieldsV2EntityTypeFieldsReorderPostRequest) -> Result<(), Error<CustomFieldsV2EntityTypeFieldsReorderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/{entityType}/fields/reorder", local_var_configuration.base_path, entityType=crate::apis::urlencode(entity_type));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_entity_type_fields_reorder_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2EntityTypeFieldsReorderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_values_entity_custom_field_get(configuration: &configuration::Configuration, entity: &str, custom_field: &str, dollar_fields: Option<&str>) -> Result<crate::models::CustomFieldValueData, Error<CustomFieldsV2ValuesEntityCustomFieldGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/values/{entity}/{customField}", local_var_configuration.base_path, entity=crate::apis::urlencode(entity), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2ValuesEntityCustomFieldGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_values_entity_custom_field_post(configuration: &configuration::Configuration, entity: &str, custom_field: &str, custom_fields_v2_values_entity_custom_field_post_request: crate::models::CustomFieldsV2ValuesEntityCustomFieldPostRequest) -> Result<(), Error<CustomFieldsV2ValuesEntityCustomFieldPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/values/{entity}/{customField}", local_var_configuration.base_path, entity=crate::apis::urlencode(entity), customField=crate::apis::urlencode(custom_field));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_values_entity_custom_field_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2ValuesEntityCustomFieldPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_values_entity_get(configuration: &configuration::Configuration, entity: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CustomFieldValueData>, Error<CustomFieldsV2ValuesEntityGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/values/{entity}", local_var_configuration.base_path, entity=crate::apis::urlencode(entity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CustomFieldsV2ValuesEntityGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn custom_fields_v2_values_entity_post(configuration: &configuration::Configuration, entity: &str, custom_fields_v2_values_entity_post_request: crate::models::CustomFieldsV2ValuesEntityPostRequest) -> Result<(), Error<CustomFieldsV2ValuesEntityPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/custom-fields-v2/values/{entity}", local_var_configuration.base_path, entity=crate::apis::urlencode(entity));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&custom_fields_v2_values_entity_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CustomFieldsV2ValuesEntityPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add custom emoji
pub async fn emojis_add_post(configuration: &configuration::Configuration, emojis_add_post_request: crate::models::EmojisAddPostRequest) -> Result<(), Error<EmojisAddPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/add", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&emojis_add_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EmojisAddPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an emoji by name
pub async fn emojis_delete_post(configuration: &configuration::Configuration, emojis_delete_post_request: crate::models::EmojisDeletePostRequest) -> Result<(), Error<EmojisDeletePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/delete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&emojis_delete_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EmojisDeletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check whether a given emoji name exists
pub async fn emojis_exists_get(configuration: &configuration::Configuration, emoji: &str) -> Result<bool, Error<EmojisExistsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/exists", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("emoji", &emoji.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EmojisExistsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List frequently used emojis
pub async fn emojis_frequently_used_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<EmojisFrequentlyUsedGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/frequently-used", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EmojisFrequentlyUsedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Record emojis usage and update frequently used list
pub async fn emojis_record_usage_post(configuration: &configuration::Configuration, emojis_record_usage_post_request: crate::models::EmojisRecordUsagePostRequest) -> Result<(), Error<EmojisRecordUsagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/record-usage", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&emojis_record_usage_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EmojisRecordUsagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search for emoji
pub async fn emojis_search_get(configuration: &configuration::Configuration, query: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, version: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::EmojisSearchGet200Response, Error<EmojisSearchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = version {
        local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EmojisSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get custom emojis for synchronization with third-party system. Custom emojis with etag greater than specified value are returned. Read more in the [documentation](https://www.jetbrains.com/help/space/sync-api.html).
pub async fn emojis_sync_batch_get(configuration: &configuration::Configuration, batch_info: &str, dollar_fields: Option<&str>) -> Result<crate::models::EmojisSyncBatchGet200Response, Error<EmojisSyncBatchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/emojis/sync-batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("batchInfo", &batch_info.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EmojisSyncBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set default status to move external issues to when linked merge request is merged in Space
pub async fn external_issues_default_issue_status_for_mr_merge_post(configuration: &configuration::Configuration, external_issues_default_issue_status_for_mr_merge_post_request: crate::models::ExternalIssuesDefaultIssueStatusForMrMergePostRequest) -> Result<(), Error<ExternalIssuesDefaultIssueStatusForMrMergePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/default-issue-status-for-mr-merge", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_default_issue_status_for_mr_merge_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesDefaultIssueStatusForMrMergePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch events about external issues from Space
pub async fn external_issues_events_queue_get(configuration: &configuration::Configuration, batch_size: i32, from_etag: Option<i64>, issue_code_linking_events_shape: Option<ExternalIssueCodeLinkingEventsShape>, include_commit_changes: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ExternalIssueEventQueueItemsBatch, Error<ExternalIssuesEventsQueueGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/events-queue", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from_etag {
        local_var_req_builder = local_var_req_builder.query(&[("fromEtag", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("batchSize", &batch_size.to_string())]);
    if let Some(ref local_var_str) = issue_code_linking_events_shape {
        local_var_req_builder = local_var_req_builder.query(&[("issueCodeLinkingEventsShape", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_commit_changes {
        local_var_req_builder = local_var_req_builder.query(&[("includeCommitChanges", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExternalIssuesEventsQueueGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_issues_external_tracker_projects_delete(configuration: &configuration::Configuration, issue_prefix: &str) -> Result<(), Error<ExternalIssuesExternalTrackerProjectsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/external-tracker-projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("issuePrefix", &issue_prefix.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesExternalTrackerProjectsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_issues_external_tracker_projects_get(configuration: &configuration::Configuration, application: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ExternalIssueTrackerProjectApi>, Error<ExternalIssuesExternalTrackerProjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/external-tracker-projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("application", &application.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExternalIssuesExternalTrackerProjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_issues_external_tracker_projects_post(configuration: &configuration::Configuration, external_issues_external_tracker_projects_post_request: crate::models::ExternalIssuesExternalTrackerProjectsPostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CreateExternalIssueProjectResult>, Error<ExternalIssuesExternalTrackerProjectsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/external-tracker-projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_external_tracker_projects_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExternalIssuesExternalTrackerProjectsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide information about an issue from external issue tracker
pub async fn external_issues_issue_content_post(configuration: &configuration::Configuration, external_issues_issue_content_post_request: crate::models::ExternalIssuesIssueContentPostRequest) -> Result<(), Error<ExternalIssuesIssueContentPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issue-content", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_issue_content_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssueContentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Provide Space with all possible statuses for external issues for a given project
pub async fn external_issues_issue_statuses_post(configuration: &configuration::Configuration, external_issues_issue_statuses_post_request: crate::models::ExternalIssuesIssueStatusesPostRequest) -> Result<(), Error<ExternalIssuesIssueStatusesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issue-statuses", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_issue_statuses_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssueStatusesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove code review links from an existing issue in a project
pub async fn external_issues_issues_issue_prefix_issue_id_code_reviews_delete(configuration: &configuration::Configuration, issue_prefix: &str, issue_id: &str, project: &str, code_review_ids: Vec<String>) -> Result<(), Error<ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issues/{issuePrefix}/{issueId}/code-reviews", local_var_configuration.base_path, issuePrefix=crate::apis::urlencode(issue_prefix), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&code_review_ids.into_iter().map(|p| ("codeReviewIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("codeReviewIds", &code_review_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add code review links to an existing issue in a project
pub async fn external_issues_issues_issue_prefix_issue_id_code_reviews_post(configuration: &configuration::Configuration, issue_prefix: &str, issue_id: &str, external_issues_issues_issue_prefix_issue_id_code_reviews_post_request: crate::models::ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsPostRequest) -> Result<(), Error<ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issues/{issuePrefix}/{issueId}/code-reviews", local_var_configuration.base_path, issuePrefix=crate::apis::urlencode(issue_prefix), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_issues_issue_prefix_issue_id_code_reviews_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssuesIssuePrefixIssueIdCodeReviewsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove commit links from an existing issue in a project
pub async fn external_issues_issues_issue_prefix_issue_id_commits_delete(configuration: &configuration::Configuration, issue_prefix: &str, issue_id: &str, project: &str, repository: &str, commit_ids: Vec<String>) -> Result<(), Error<ExternalIssuesIssuesIssuePrefixIssueIdCommitsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issues/{issuePrefix}/{issueId}/commits", local_var_configuration.base_path, issuePrefix=crate::apis::urlencode(issue_prefix), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("repository", &repository.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&commit_ids.into_iter().map(|p| ("commitIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("commitIds", &commit_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssuesIssuePrefixIssueIdCommitsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add commit links to an existing issue in a project
pub async fn external_issues_issues_issue_prefix_issue_id_commits_post(configuration: &configuration::Configuration, issue_prefix: &str, issue_id: &str, external_issues_issues_issue_prefix_issue_id_commits_post_request: crate::models::ExternalIssuesIssuesIssuePrefixIssueIdCommitsPostRequest) -> Result<(), Error<ExternalIssuesIssuesIssuePrefixIssueIdCommitsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/issues/{issuePrefix}/{issueId}/commits", local_var_configuration.base_path, issuePrefix=crate::apis::urlencode(issue_prefix), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_issues_issue_prefix_issue_id_commits_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesIssuesIssuePrefixIssueIdCommitsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Notify Space about issues that were deleted in external issue tracker
pub async fn external_issues_mark_issues_as_deleted_post(configuration: &configuration::Configuration, external_issues_mark_issues_as_deleted_post_request: crate::models::ExternalIssuesMarkIssuesAsDeletedPostRequest) -> Result<(), Error<ExternalIssuesMarkIssuesAsDeletedPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-issues/mark-issues-as-deleted", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_issues_mark_issues_as_deleted_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalIssuesMarkIssuesAsDeletedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_link_patterns_delete(configuration: &configuration::Configuration, pattern: &str) -> Result<(), Error<ExternalLinkPatternsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-link-patterns", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("pattern", &pattern.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalLinkPatternsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_link_patterns_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ExternalLinkPattern>, Error<ExternalLinkPatternsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-link-patterns", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ExternalLinkPatternsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn external_link_patterns_post(configuration: &configuration::Configuration, external_link_patterns_post_request: crate::models::ExternalLinkPatternsPostRequest) -> Result<(), Error<ExternalLinkPatternsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/external-link-patterns", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&external_link_patterns_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ExternalLinkPatternsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the HTTP API model that describes the available HTTP APIs
pub async fn http_api_model_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::HaModel, Error<HttpApiModelGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/http-api-model", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HttpApiModelGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve an issue by its identifier
pub async fn issues_get(configuration: &configuration::Configuration, issue_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::Issue, Error<IssuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/issues", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("issueId", &issue_id.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IssuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve list of issues by identifiers. Issues can belong to different projects. Up to 100 issues can be retrieved within a single request. See also [Get all issues](/extensions/httpApiPlayground?resource=projects_xxx_planning_issues&endpoint=rest_query) (`/projects/{project}/planning/issues`)
pub async fn issues_get_by_ids_post(configuration: &configuration::Configuration, issues_get_by_ids_post_request: crate::models::IssuesGetByIdsPostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::Issue>, Error<IssuesGetByIdsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/issues/get-by-ids", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&issues_get_by_ids_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<IssuesGetByIdsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List subscriptions for a channel
pub async fn notifications_channel_subscriptions_get(configuration: &configuration::Configuration, channel: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SubscriptionDto>, Error<NotificationsChannelSubscriptionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/channel-subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("channel", &channel.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsChannelSubscriptionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete channel subscription
pub async fn notifications_channel_subscriptions_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<NotificationsChannelSubscriptionsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/channel-subscriptions/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsChannelSubscriptionsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update subscription for a channel
pub async fn notifications_channel_subscriptions_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, notifications_channel_subscriptions_id_patch_request: Option<crate::models::NotificationsChannelSubscriptionsIdPatchRequest>) -> Result<crate::models::SubscriptionDto, Error<NotificationsChannelSubscriptionsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/channel-subscriptions/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_channel_subscriptions_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsChannelSubscriptionsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Ensures that all permissions required for this subscription are requested in the corresponding permission role
pub async fn notifications_channel_subscriptions_id_request_missing_rights_post(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<NotificationsChannelSubscriptionsIdRequestMissingRightsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/channel-subscriptions/{id}/request-missing-rights", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsChannelSubscriptionsIdRequestMissingRightsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add subscription for a channel
pub async fn notifications_channel_subscriptions_post(configuration: &configuration::Configuration, notifications_channel_subscriptions_post_request: crate::models::NotificationsChannelSubscriptionsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::SubscriptionDto, Error<NotificationsChannelSubscriptionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/channel-subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_channel_subscriptions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsChannelSubscriptionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all subscription subjects
pub async fn notifications_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EventSubjectInfoDto>, Error<NotificationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List personal custom subscriptions
pub async fn notifications_personal_custom_subscriptions_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SubscriptionDto>, Error<NotificationsPersonalCustomSubscriptionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-custom-subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profile", &profile.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPersonalCustomSubscriptionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete personal custom subscription
pub async fn notifications_personal_custom_subscriptions_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<NotificationsPersonalCustomSubscriptionsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-custom-subscriptions/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsPersonalCustomSubscriptionsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create personal custom subscription
pub async fn notifications_personal_custom_subscriptions_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, notifications_personal_custom_subscriptions_id_patch_request: Option<crate::models::NotificationsPersonalCustomSubscriptionsIdPatchRequest>) -> Result<crate::models::SubscriptionDto, Error<NotificationsPersonalCustomSubscriptionsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-custom-subscriptions/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_personal_custom_subscriptions_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPersonalCustomSubscriptionsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create personal custom subscription
pub async fn notifications_personal_custom_subscriptions_post(configuration: &configuration::Configuration, notifications_personal_custom_subscriptions_post_request: crate::models::NotificationsPersonalCustomSubscriptionsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::SubscriptionDto, Error<NotificationsPersonalCustomSubscriptionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-custom-subscriptions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_personal_custom_subscriptions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPersonalCustomSubscriptionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all personal subscription targets
pub async fn notifications_personal_subscriptions_all_personal_subscription_targets_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PersonalSubscriptionTarget>, Error<NotificationsPersonalSubscriptionsAllPersonalSubscriptionTargetsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-subscriptions/all-personal-subscription-targets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPersonalSubscriptionsAllPersonalSubscriptionTargetsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get personal subscription settings for a member
pub async fn notifications_personal_subscriptions_personal_subscription_settings_get(configuration: &configuration::Configuration, profile: &str, feed: &str, dollar_fields: Option<&str>) -> Result<crate::models::PersonalSubscriptionSettings, Error<NotificationsPersonalSubscriptionsPersonalSubscriptionSettingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-subscriptions/personal-subscription-settings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profile", &profile.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("feed", &feed.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPersonalSubscriptionsPersonalSubscriptionSettingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update personal subscription settings for a member
pub async fn notifications_personal_subscriptions_update_personal_subscription_subject_post(configuration: &configuration::Configuration, notifications_personal_subscriptions_update_personal_subscription_subject_post_request: crate::models::NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionSubjectPostRequest) -> Result<(), Error<NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionSubjectPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-subscriptions/update-personal-subscription-subject", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_personal_subscriptions_update_personal_subscription_subject_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionSubjectPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update personal subscription settings for a member
pub async fn notifications_personal_subscriptions_update_personal_subscription_target_post(configuration: &configuration::Configuration, notifications_personal_subscriptions_update_personal_subscription_target_post_request: crate::models::NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionTargetPostRequest) -> Result<(), Error<NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionTargetPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/personal-subscriptions/update-personal-subscription-target", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_personal_subscriptions_update_personal_subscription_target_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsPersonalSubscriptionsUpdatePersonalSubscriptionTargetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List personal feeds for a member
pub async fn notifications_private_feeds_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PrivateFeed>, Error<NotificationsPrivateFeedsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/private-feeds", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profile", &profile.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPrivateFeedsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete personal feed for member
pub async fn notifications_private_feeds_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<NotificationsPrivateFeedsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/private-feeds/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<NotificationsPrivateFeedsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update personal feed for a member
pub async fn notifications_private_feeds_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, notifications_private_feeds_id_patch_request: Option<crate::models::NotificationsPrivateFeedsIdPatchRequest>) -> Result<crate::models::PrivateFeed, Error<NotificationsPrivateFeedsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/private-feeds/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_private_feeds_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPrivateFeedsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create personal feed for member
pub async fn notifications_private_feeds_post(configuration: &configuration::Configuration, notifications_private_feeds_post_request: crate::models::NotificationsPrivateFeedsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PrivateFeed, Error<NotificationsPrivateFeedsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/notifications/private-feeds", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notifications_private_feeds_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<NotificationsPrivateFeedsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_domains_check_get(configuration: &configuration::Configuration, domain: &str) -> Result<crate::models::CDomainStatus, Error<OrganizationDomainsCheckGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization/domains/check", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("domain", &domain.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganizationDomainsCheckGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_domains_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::OrgDomainDto>, Error<OrganizationDomainsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization/domains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganizationDomainsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_domains_patch(configuration: &configuration::Configuration, organization_domains_patch_request: crate::models::OrganizationDomainsPatchRequest) -> Result<(), Error<OrganizationDomainsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization/domains", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&organization_domains_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrganizationDomainsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::OrganizationRecord, Error<OrganizationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganizationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_jet_sales_license_activation_url_get(configuration: &configuration::Configuration, ) -> Result<String, Error<OrganizationJetSalesLicenseActivationUrlGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization/jet-sales/license-activation-url", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganizationJetSalesLicenseActivationUrlGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_jet_sales_url_get(configuration: &configuration::Configuration, ) -> Result<String, Error<OrganizationJetSalesUrlGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization/jet-sales/url", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrganizationJetSalesUrlGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn organization_patch(configuration: &configuration::Configuration, organization_patch_request: crate::models::OrganizationPatchRequest) -> Result<(), Error<OrganizationPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/organization", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&organization_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrganizationPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create new custom permission role in specified permission context
pub async fn permission_roles_create_post(configuration: &configuration::Configuration, permission_roles_create_post_request: crate::models::PermissionRolesCreatePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::RoleDto, Error<PermissionRolesCreatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/create", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&permission_roles_create_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesCreatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all permission roles in permission context
pub async fn permission_roles_get_post(configuration: &configuration::Configuration, applications_application_ui_extensions_disable_for_everybody_patch_request: crate::models::ApplicationsApplicationUiExtensionsDisableForEverybodyPatchRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::RoleDto>, Error<PermissionRolesGetPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/get", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_ui_extensions_disable_for_everybody_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesGetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get 2FA requirement for permission role
pub async fn permission_roles_role_id2_fa_requirement_get(configuration: &configuration::Configuration, role_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TwoFactorAuthenticationRequirement, Error<PermissionRolesRoleId2FaRequirementGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/2-fa-requirement", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesRoleId2FaRequirementGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set 2FA requirement for permission role
pub async fn permission_roles_role_id2_fa_requirement_patch(configuration: &configuration::Configuration, role_id: &str, permission_roles_role_id2_fa_requirement_patch_request: Option<crate::models::PermissionRolesRoleId2FaRequirementPatchRequest>) -> Result<(), Error<PermissionRolesRoleId2FaRequirementPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/2-fa-requirement", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&permission_roles_role_id2_fa_requirement_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleId2FaRequirementPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete custom permission role
pub async fn permission_roles_role_id_delete(configuration: &configuration::Configuration, role_id: &str) -> Result<(), Error<PermissionRolesRoleIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update custom permission role name
pub async fn permission_roles_role_id_patch(configuration: &configuration::Configuration, role_id: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest) -> Result<(), Error<PermissionRolesRoleIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revoke permissions from the specified role.
pub async fn permission_roles_role_id_permissions_delete(configuration: &configuration::Configuration, role_id: &str, right_codes: Vec<String>) -> Result<(), Error<PermissionRolesRoleIdPermissionsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/permissions", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&right_codes.into_iter().map(|p| ("rightCodes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("rightCodes", &right_codes.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdPermissionsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get role permissions
pub async fn permission_roles_role_id_permissions_get(configuration: &configuration::Configuration, role_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::RightDto>, Error<PermissionRolesRoleIdPermissionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/permissions", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdPermissionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn permission_roles_role_id_permissions_post(configuration: &configuration::Configuration, role_id: &str, permission_roles_role_id_permissions_post_request: crate::models::PermissionRolesRoleIdPermissionsPostRequest) -> Result<(), Error<PermissionRolesRoleIdPermissionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/permissions", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&permission_roles_role_id_permissions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdPermissionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of profiles with the specified role
pub async fn permission_roles_role_id_profiles_get(configuration: &configuration::Configuration, role_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<PermissionRolesRoleIdProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/profiles", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove permission role from the profile
pub async fn permission_roles_role_id_profiles_profile_delete(configuration: &configuration::Configuration, role_id: &str, profile: &str) -> Result<(), Error<PermissionRolesRoleIdProfilesProfileDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/profiles/{profile}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id), profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdProfilesProfileDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Assign permission role to the profile
pub async fn permission_roles_role_id_profiles_profile_post(configuration: &configuration::Configuration, role_id: &str, profile: &str) -> Result<(), Error<PermissionRolesRoleIdProfilesProfilePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/profiles/{profile}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id), profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdProfilesProfilePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reset permissions for the role to the standard ones. Only applicable to roles with PermissionRoleType = PREDEFINED, not applicable to custom roles.
pub async fn permission_roles_role_id_reset_role_permissions_to_default_post(configuration: &configuration::Configuration, role_id: &str) -> Result<(), Error<PermissionRolesRoleIdResetRolePermissionsToDefaultPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/reset-role-permissions-to-default", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdResetRolePermissionsToDefaultPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of teams with the specified role
pub async fn permission_roles_role_id_teams_get(configuration: &configuration::Configuration, role_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdTeam>, Error<PermissionRolesRoleIdTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/teams", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove permission role from the team
pub async fn permission_roles_role_id_teams_team_delete(configuration: &configuration::Configuration, role_id: &str, team: &str) -> Result<(), Error<PermissionRolesRoleIdTeamsTeamDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/teams/{team}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id), team=crate::apis::urlencode(team));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdTeamsTeamDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Assign permission role to the team
pub async fn permission_roles_role_id_teams_team_post(configuration: &configuration::Configuration, role_id: &str, team: &str) -> Result<(), Error<PermissionRolesRoleIdTeamsTeamPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permission-roles/{roleId}/teams/{team}", local_var_configuration.base_path, roleId=crate::apis::urlencode(role_id), team=crate::apis::urlencode(team));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PermissionRolesRoleIdTeamsTeamPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn permissions_check_permission_post(configuration: &configuration::Configuration, permissions_check_permission_post_request: crate::models::PermissionsCheckPermissionPostRequest) -> Result<bool, Error<PermissionsCheckPermissionPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permissions/check-permission", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&permissions_check_permission_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionsCheckPermissionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn permissions_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::DtoRightsWithHierarchy, Error<PermissionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/permissions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PermissionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_deployment_targets_audit_log_get(configuration: &configuration::Configuration, target_identifier: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsAutomationDeploymentTargetsAuditLogGet200Response, Error<ProjectsAutomationDeploymentTargetsAuditLogGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/deployment-targets/audit-log", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("targetIdentifier", &target_identifier.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationDeploymentTargetsAuditLogGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_deployment_targets_full_number_id_get(configuration: &configuration::Configuration, full_number_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::DeployTargetRecord, Error<ProjectsAutomationDeploymentTargetsFullNumberIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/deployment-targets/{fullNumberId}", local_var_configuration.base_path, fullNumberId=crate::apis::urlencode(full_number_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationDeploymentTargetsFullNumberIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_deployment_targets_get(configuration: &configuration::Configuration, project: Option<&str>, search: Option<&str>, custom_filters: Option<Vec<String>>, sort_by: Option<&str>, sort_order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsAutomationDeploymentTargetsSearchPost200Response, Error<ProjectsAutomationDeploymentTargetsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/deployment-targets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = project {
        local_var_req_builder = local_var_req_builder.query(&[("project", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search {
        local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = custom_filters {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("customFilters".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("customFilters", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationDeploymentTargetsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_deployment_targets_search_post(configuration: &configuration::Configuration, projects_automation_deployment_targets_search_post_request: crate::models::ProjectsAutomationDeploymentTargetsSearchPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsAutomationDeploymentTargetsSearchPost200Response, Error<ProjectsAutomationDeploymentTargetsSearchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/deployment-targets/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_automation_deployment_targets_search_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationDeploymentTargetsSearchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_dsl_evaluations_config_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::DslEvaluationConfig, Error<ProjectsAutomationDslEvaluationsConfigGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/dsl-evaluations/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationDslEvaluationsConfigGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_graph_executions_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::JobExecutionDto, Error<ProjectsAutomationGraphExecutionsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/graph-executions/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationGraphExecutionsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stop execution by ExecutionId
pub async fn projects_automation_graph_executions_id_stop_post(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<ProjectsAutomationGraphExecutionsIdStopPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/graph-executions/{id}/stop", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsAutomationGraphExecutionsIdStopPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the job execution associated to the currently authenticated principal. This endpoint can only be used with the credentials provided to an Automation job.
pub async fn projects_automation_job_executions_current_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<crate::models::JobExecutionDto, Error<ProjectsAutomationJobExecutionsCurrentGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/job-executions/current", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationJobExecutionsCurrentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_jobs_job_id_get(configuration: &configuration::Configuration, job_id: &str, project: &str, dollar_fields: Option<&str>) -> Result<crate::models::JobDto, Error<ProjectsAutomationJobsJobIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/jobs/{jobId}", local_var_configuration.base_path, jobId=crate::apis::urlencode(job_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationJobsJobIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_step_executions_step_exec_id_parameters_key_get(configuration: &configuration::Configuration, step_exec_id: &str, key: &str) -> Result<String, Error<ProjectsAutomationStepExecutionsStepExecIdParametersKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/step-executions/{stepExecId}/parameters/{key}", local_var_configuration.base_path, stepExecId=crate::apis::urlencode(step_exec_id), key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationStepExecutionsStepExecIdParametersKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_step_executions_step_exec_id_parameters_key_patch(configuration: &configuration::Configuration, step_exec_id: &str, key: &str, applications_parameters_key_patch_request: crate::models::ApplicationsParametersKeyPatchRequest) -> Result<(), Error<ProjectsAutomationStepExecutionsStepExecIdParametersKeyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/step-executions/{stepExecId}/parameters/{key}", local_var_configuration.base_path, stepExecId=crate::apis::urlencode(step_exec_id), key=crate::apis::urlencode(key));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_parameters_key_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsAutomationStepExecutionsStepExecIdParametersKeyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_step_executions_used_parameters_param_parameter_id_get(configuration: &configuration::Configuration, parameter_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ParameterLastUsageDto>, Error<ProjectsAutomationStepExecutionsUsedParametersParamParameterIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/step-executions/used-parameters/param/{parameterId}", local_var_configuration.base_path, parameterId=crate::apis::urlencode(parameter_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationStepExecutionsUsedParametersParamParameterIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_automation_step_executions_used_parameters_secret_secret_id_get(configuration: &configuration::Configuration, secret_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ParameterLastUsageDto>, Error<ProjectsAutomationStepExecutionsUsedParametersSecretSecretIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/step-executions/used-parameters/secret/{secretId}", local_var_configuration.base_path, secretId=crate::apis::urlencode(secret_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsAutomationStepExecutionsUsedParametersSecretSecretIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete the legacy subscription channels matching the given filters (applied as AND). If no filter is provided, all subscription channels corresponding to unsubscribed jobs for the logged in user are deleted.
pub async fn projects_automation_subscriptions_legacy_channels_delete(configuration: &configuration::Configuration, project: Option<&str>, job_id: Option<&str>, unsubscribed_only: Option<bool>) -> Result<(), Error<ProjectsAutomationSubscriptionsLegacyChannelsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/automation/subscriptions/legacy-channels", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = project {
        local_var_req_builder = local_var_req_builder.query(&[("project", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_id {
        local_var_req_builder = local_var_req_builder.query(&[("jobId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = unsubscribed_only {
        local_var_req_builder = local_var_req_builder.query(&[("unsubscribedOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsAutomationSubscriptionsLegacyChannelsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all projects in which given user is a collaborator
pub async fn projects_collaboratorprofile_get(configuration: &configuration::Configuration, profile: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsCollaboratorprofileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/collaborator:{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsCollaboratorprofileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all projects. Parameters are applied as 'AND' filters.
pub async fn projects_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, term: Option<&str>, tag: Option<&str>, starred: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = term {
        local_var_req_builder = local_var_req_builder.query(&[("term", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tag {
        local_var_req_builder = local_var_req_builder.query(&[("tag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starred {
        local_var_req_builder = local_var_req_builder.query(&[("starred", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all projects for a member
pub async fn projects_membermember_get(configuration: &configuration::Configuration, member: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsMembermemberGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/member:{member}", local_var_configuration.base_path, member=crate::apis::urlencode(member));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsMembermemberGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List project parameters in a parameter bundle
pub async fn projects_params_default_bundle_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsParamsDefaultBundleGet200Response, Error<ProjectsParamsDefaultBundleGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsParamsDefaultBundleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new project parameter in the default parameter bundle
pub async fn projects_params_default_bundle_post(configuration: &configuration::Configuration, projects_params_default_bundle_post_request: crate::models::ProjectsParamsDefaultBundlePostRequest) -> Result<String, Error<ProjectsParamsDefaultBundlePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_params_default_bundle_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsParamsDefaultBundlePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a project parameter
pub async fn projects_params_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<ProjectsParamsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsParamsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a project parameter
pub async fn projects_params_id_patch(configuration: &configuration::Configuration, id: &str, projects_params_id_patch_request: crate::models::ProjectsParamsIdPatchRequest) -> Result<(), Error<ProjectsParamsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_params_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsParamsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List project parameters in a parameter bundle
pub async fn projects_params_in_default_bundle_get(configuration: &configuration::Configuration, project_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsParamsDefaultBundleGet200Response, Error<ProjectsParamsInDefaultBundleGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/in-default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("projectId", &project_id.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsParamsInDefaultBundleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_params_in_default_bundle_post(configuration: &configuration::Configuration, projects_params_in_default_bundle_post_request: crate::models::ProjectsParamsInDefaultBundlePostRequest) -> Result<String, Error<ProjectsParamsInDefaultBundlePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/params/in-default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_params_in_default_bundle_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsParamsInDefaultBundlePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing board. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_board_delete(configuration: &configuration::Configuration, board: &str) -> Result<(), Error<ProjectsPlanningBoardsBoardDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}", local_var_configuration.base_path, board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a board by identifier
pub async fn projects_planning_boards_board_get(configuration: &configuration::Configuration, board: &str, dollar_fields: Option<&str>) -> Result<crate::models::BoardRecord, Error<ProjectsPlanningBoardsBoardGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}", local_var_configuration.base_path, board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch issues from the board across all its non-archived sprints
pub async fn projects_planning_boards_board_issues_get(configuration: &configuration::Configuration, board: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsPlanningBoardsSprintsSprintIssuesGet200Response, Error<ProjectsPlanningBoardsBoardIssuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}/issues", local_var_configuration.base_path, board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardIssuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an existing issue in a project from a board or all of its sprints
pub async fn projects_planning_boards_board_issues_issue_delete(configuration: &configuration::Configuration, issue: &str, board: &str) -> Result<(), Error<ProjectsPlanningBoardsBoardIssuesIssueDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}/issues/{issue}", local_var_configuration.base_path, issue=crate::apis::urlencode(issue), board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardIssuesIssueDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add an existing issue in a project to a board or its current sprint
pub async fn projects_planning_boards_board_issues_issue_post(configuration: &configuration::Configuration, issue: &str, board: &str) -> Result<(), Error<ProjectsPlanningBoardsBoardIssuesIssuePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}/issues/{issue}", local_var_configuration.base_path, issue=crate::apis::urlencode(issue), board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardIssuesIssuePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing board. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_board_patch(configuration: &configuration::Configuration, board: &str, projects_planning_boards_board_patch_request: Option<crate::models::ProjectsPlanningBoardsBoardPatchRequest>) -> Result<(), Error<ProjectsPlanningBoardsBoardPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/{board}", local_var_configuration.base_path, board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_planning_boards_board_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsBoardPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new sprint in a board. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_sprints_post(configuration: &configuration::Configuration, projects_planning_boards_sprints_post_request: crate::models::ProjectsPlanningBoardsSprintsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::SprintRecord, Error<ProjectsPlanningBoardsSprintsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_planning_boards_sprints_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive closed or planned sprint. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_sprints_sprint_archive_delete(configuration: &configuration::Configuration, sprint: &str) -> Result<(), Error<ProjectsPlanningBoardsSprintsSprintArchiveDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}/archive", local_var_configuration.base_path, sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintArchiveDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch issues from an existing non-archived sprint
pub async fn projects_planning_boards_sprints_sprint_issues_get(configuration: &configuration::Configuration, sprint: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, unresolved_only: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsPlanningBoardsSprintsSprintIssuesGet200Response, Error<ProjectsPlanningBoardsSprintsSprintIssuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}/issues", local_var_configuration.base_path, sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = unresolved_only {
        local_var_req_builder = local_var_req_builder.query(&[("unresolvedOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintIssuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an existing issue in a project from a sprint.
pub async fn projects_planning_boards_sprints_sprint_issues_issue_delete(configuration: &configuration::Configuration, issue: &str, sprint: &str) -> Result<(), Error<ProjectsPlanningBoardsSprintsSprintIssuesIssueDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}/issues/{issue}", local_var_configuration.base_path, issue=crate::apis::urlencode(issue), sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintIssuesIssueDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add an existing issue in a project to a sprint
pub async fn projects_planning_boards_sprints_sprint_issues_issue_post(configuration: &configuration::Configuration, issue: &str, sprint: &str) -> Result<(), Error<ProjectsPlanningBoardsSprintsSprintIssuesIssuePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}/issues/{issue}", local_var_configuration.base_path, issue=crate::apis::urlencode(issue), sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintIssuesIssuePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Launch a planned sprint. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_sprints_sprint_launch_post(configuration: &configuration::Configuration, sprint: &str, projects_planning_boards_sprints_sprint_launch_post_request: crate::models::ProjectsPlanningBoardsSprintsSprintLaunchPostRequest) -> Result<(), Error<ProjectsPlanningBoardsSprintsSprintLaunchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}/launch", local_var_configuration.base_path, sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_planning_boards_sprints_sprint_launch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintLaunchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing sprint in a board. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_planning_boards_sprints_sprint_patch(configuration: &configuration::Configuration, sprint: &str, projects_planning_boards_sprints_sprint_patch_request: Option<crate::models::ProjectsPlanningBoardsSprintsSprintPatchRequest>) -> Result<(), Error<ProjectsPlanningBoardsSprintsSprintPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/planning/boards/sprints/{sprint}", local_var_configuration.base_path, sprint=crate::apis::urlencode(sprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_planning_boards_sprints_sprint_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPlanningBoardsSprintsSprintPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new project
pub async fn projects_post(configuration: &configuration::Configuration, projects_post_request: crate::models::ProjectsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PrProject, Error<ProjectsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List private projects in the current organization
pub async fn projects_private_projects_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PrPrivateProject>, Error<ProjectsPrivateProjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/private-projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsPrivateProjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request access to a project
pub async fn projects_private_projects_project_request_access_post(configuration: &configuration::Configuration, project: &str) -> Result<(), Error<ProjectsPrivateProjectsProjectRequestAccessPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/private-projects/{project}/request-access", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsPrivateProjectsProjectRequestAccessPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of all project administrators
pub async fn projects_project_access_admins_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<ProjectsProjectAccessAdminsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/admins", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessAdminsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a member as administrator to a project
pub async fn projects_project_access_admins_profiles_post(configuration: &configuration::Configuration, project: &str, chats_channels_channel_administrator_patch_request: crate::models::ChatsChannelsChannelAdministratorPatchRequest) -> Result<(), Error<ProjectsProjectAccessAdminsProfilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/admins/profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_administrator_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessAdminsProfilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a member as administrator from a project
pub async fn projects_project_access_admins_profiles_profile_delete(configuration: &configuration::Configuration, project: &str, profile: &str) -> Result<(), Error<ProjectsProjectAccessAdminsProfilesProfileDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/admins/profiles/{profile}", local_var_configuration.base_path, project=crate::apis::urlencode(project), profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessAdminsProfilesProfileDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a team as administrators to a project
pub async fn projects_project_access_admins_teams_post(configuration: &configuration::Configuration, project: &str, projects_project_access_admins_teams_post_request: crate::models::ProjectsProjectAccessAdminsTeamsPostRequest) -> Result<(), Error<ProjectsProjectAccessAdminsTeamsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/admins/teams", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_access_admins_teams_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessAdminsTeamsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a team as administrators from a project
pub async fn projects_project_access_admins_teams_team_id_delete(configuration: &configuration::Configuration, project: &str, team_id: &str) -> Result<(), Error<ProjectsProjectAccessAdminsTeamsTeamIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/admins/teams/{teamId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), teamId=crate::apis::urlencode(team_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessAdminsTeamsTeamIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<ProjectsProjectAccessCollaboratorsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_profiles_delete(configuration: &configuration::Configuration, project: &str, profile: &str) -> Result<(), Error<ProjectsProjectAccessCollaboratorsProfilesDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("profile", &profile.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsProfilesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_profiles_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<ProjectsProjectAccessCollaboratorsProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_profiles_post(configuration: &configuration::Configuration, project: &str, chats_channels_channel_administrator_patch_request: crate::models::ChatsChannelsChannelAdministratorPatchRequest) -> Result<(), Error<ProjectsProjectAccessCollaboratorsProfilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_administrator_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsProfilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_teams_delete(configuration: &configuration::Configuration, project: &str, team_id: &str) -> Result<(), Error<ProjectsProjectAccessCollaboratorsTeamsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/teams", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("teamId", &team_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsTeamsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_teams_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdTeam>, Error<ProjectsProjectAccessCollaboratorsTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/teams", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_access_collaborators_teams_post(configuration: &configuration::Configuration, project: &str, projects_project_access_admins_teams_post_request: crate::models::ProjectsProjectAccessAdminsTeamsPostRequest) -> Result<(), Error<ProjectsProjectAccessCollaboratorsTeamsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/collaborators/teams", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_access_admins_teams_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessCollaboratorsTeamsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get project members for a given project key
pub async fn projects_project_access_member_profiles_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, including_admins: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<ProjectsProjectAccessMemberProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/member-profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = including_admins {
        local_var_req_builder = local_var_req_builder.query(&[("includingAdmins", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessMemberProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a member to a project
pub async fn projects_project_access_members_profiles_post(configuration: &configuration::Configuration, project: &str, chats_channels_channel_administrator_patch_request: crate::models::ChatsChannelsChannelAdministratorPatchRequest) -> Result<(), Error<ProjectsProjectAccessMembersProfilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/members/profiles", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_administrator_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessMembersProfilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a member from a project
pub async fn projects_project_access_members_profiles_profile_delete(configuration: &configuration::Configuration, project: &str, profile: &str) -> Result<(), Error<ProjectsProjectAccessMembersProfilesProfileDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/members/profiles/{profile}", local_var_configuration.base_path, project=crate::apis::urlencode(project), profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessMembersProfilesProfileDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a team from a project
pub async fn projects_project_access_members_teams_team_id_delete(configuration: &configuration::Configuration, project: &str, team_id: &str) -> Result<(), Error<ProjectsProjectAccessMembersTeamsTeamIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/members/teams/{teamId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), teamId=crate::apis::urlencode(team_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAccessMembersTeamsTeamIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get organization members who can view a project
pub async fn projects_project_access_viewers_get(configuration: &configuration::Configuration, project: &str, term: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, me_on_top: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<ProjectsProjectAccessViewersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/access/viewers", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("term", &term.to_string())]);
    if let Some(ref local_var_str) = me_on_top {
        local_var_req_builder = local_var_req_builder.query(&[("meOnTop", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAccessViewersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_favorites_get(configuration: &configuration::Configuration, project: &str, sort_by: Option<&str>, sort_order: Option<ColumnSortOrder>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::DeployTargetRecord>, Error<ProjectsProjectAutomationDeploymentTargetsFavoritesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets/favorites", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsFavoritesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_get(configuration: &configuration::Configuration, project: &str, search: Option<&str>, custom_filters: Option<Vec<String>>, show_archived: Option<bool>, sort_by: Option<&str>, sort_order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsAutomationDeploymentTargetsSearchPost200Response, Error<ProjectsProjectAutomationDeploymentTargetsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = search {
        local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = custom_filters {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("customFilters".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("customFilters", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = show_archived {
        local_var_req_builder = local_var_req_builder.query(&[("showArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_order {
        local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_post(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployment_targets_post_request: crate::models::ProjectsProjectAutomationDeploymentTargetsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeployTargetRecord, Error<ProjectsProjectAutomationDeploymentTargetsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployment_targets_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_target_delete(configuration: &configuration::Configuration, project: &str, target: &str) -> Result<(), Error<ProjectsProjectAutomationDeploymentTargetsTargetDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets/{target}", local_var_configuration.base_path, project=crate::apis::urlencode(project), target=crate::apis::urlencode(target));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsTargetDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_target_get(configuration: &configuration::Configuration, project: &str, target: &str, dollar_fields: Option<&str>) -> Result<crate::models::DeployTargetRecord, Error<ProjectsProjectAutomationDeploymentTargetsTargetGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets/{target}", local_var_configuration.base_path, project=crate::apis::urlencode(project), target=crate::apis::urlencode(target));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsTargetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployment_targets_target_patch(configuration: &configuration::Configuration, project: &str, target: &str, projects_project_automation_deployment_targets_target_patch_request: Option<crate::models::ProjectsProjectAutomationDeploymentTargetsTargetPatchRequest>) -> Result<(), Error<ProjectsProjectAutomationDeploymentTargetsTargetPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployment-targets/{target}", local_var_configuration.base_path, project=crate::apis::urlencode(project), target=crate::apis::urlencode(target));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployment_targets_target_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentTargetsTargetPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_fail_post(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployments_fail_post_request: crate::models::ProjectsProjectAutomationDeploymentsFailPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsFailPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/fail", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployments_fail_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_finish_post(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployments_finish_post_request: crate::models::ProjectsProjectAutomationDeploymentsFinishPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsFinishPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/finish", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployments_finish_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsFinishPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_get(configuration: &configuration::Configuration, project: &str, target_identifier: Option<&str>, job_execution_id: Option<&str>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectAutomationDeploymentsGet200Response, Error<ProjectsProjectAutomationDeploymentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = target_identifier {
        local_var_req_builder = local_var_req_builder.query(&[("targetIdentifier", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_execution_id {
        local_var_req_builder = local_var_req_builder.query(&[("jobExecutionId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_patch(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployments_patch_request: crate::models::ProjectsProjectAutomationDeploymentsPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployments_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_schedule_post(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployments_schedule_post_request: crate::models::ProjectsProjectAutomationDeploymentsSchedulePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsSchedulePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/schedule", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployments_schedule_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsSchedulePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_start_post(configuration: &configuration::Configuration, project: &str, projects_project_automation_deployments_start_post_request: crate::models::ProjectsProjectAutomationDeploymentsStartPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsStartPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/start", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_deployments_start_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsStartPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_target_identifier_deployment_identifier_delete(configuration: &configuration::Configuration, project: &str, target_identifier: &str, deployment_identifier: &str) -> Result<(), Error<ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/{targetIdentifier}/{deploymentIdentifier}", local_var_configuration.base_path, project=crate::apis::urlencode(project), targetIdentifier=crate::apis::urlencode(target_identifier), deploymentIdentifier=crate::apis::urlencode(deployment_identifier));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_automation_deployments_target_identifier_deployment_identifier_get(configuration: &configuration::Configuration, project: &str, target_identifier: &str, deployment_identifier: &str, dollar_fields: Option<&str>) -> Result<crate::models::DeploymentRecord, Error<ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/deployments/{targetIdentifier}/{deploymentIdentifier}", local_var_configuration.base_path, project=crate::apis::urlencode(project), targetIdentifier=crate::apis::urlencode(target_identifier), deploymentIdentifier=crate::apis::urlencode(deployment_identifier));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationDeploymentsTargetIdentifierDeploymentIdentifierGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search executions. Parameters are applied as 'AND' filters.
pub async fn projects_project_automation_graph_executions_get(configuration: &configuration::Configuration, project: &str, job_id: &str, branch_filter: Option<&str>, status_filter: Option<ExecutionStatus>, job_trigger_filter: Option<JobTriggerType>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectAutomationGraphExecutionsGet200Response, Error<ProjectsProjectAutomationGraphExecutionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/graph-executions", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("jobId", &job_id.to_string())]);
    if let Some(ref local_var_str) = branch_filter {
        local_var_req_builder = local_var_req_builder.query(&[("branchFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status_filter {
        local_var_req_builder = local_var_req_builder.query(&[("statusFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = job_trigger_filter {
        local_var_req_builder = local_var_req_builder.query(&[("jobTriggerFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationGraphExecutionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List jobs. Parameters are applied as 'AND' filters.
pub async fn projects_project_automation_jobs_get(configuration: &configuration::Configuration, project: &str, repo_filter: &str, branch_filter: &str, trigger: Option<JobTriggerType>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectAutomationJobsGet200Response, Error<ProjectsProjectAutomationJobsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/jobs", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("repoFilter", &repo_filter.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("branchFilter", &branch_filter.to_string())]);
    if let Some(ref local_var_str) = trigger {
        local_var_req_builder = local_var_req_builder.query(&[("trigger", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationJobsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Start job. Returns ExecutionId, see projects/automation/graph-executions/{id}.
pub async fn projects_project_automation_jobs_job_id_start_post(configuration: &configuration::Configuration, project: &str, job_id: &str, projects_project_automation_jobs_job_id_start_post_request: crate::models::ProjectsProjectAutomationJobsJobIdStartPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::LaunchResult, Error<ProjectsProjectAutomationJobsJobIdStartPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/automation/jobs/{jobId}/start", local_var_configuration.base_path, project=crate::apis::urlencode(project), jobId=crate::apis::urlencode(job_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_automation_jobs_job_id_start_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectAutomationJobsJobIdStartPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_code_discussions_discussion_id_accept_suggested_edit_post(configuration: &configuration::Configuration, project: &str, discussion_id: &str, projects_project_code_reviews_code_discussions_discussion_id_accept_suggested_edit_post_request: crate::models::ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdAcceptSuggestedEditPostRequest) -> Result<(), Error<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdAcceptSuggestedEditPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/code-discussions/{discussionId}/accept-suggested-edit", local_var_configuration.base_path, project=crate::apis::urlencode(project), discussionId=crate::apis::urlencode(discussion_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_code_discussions_discussion_id_accept_suggested_edit_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdAcceptSuggestedEditPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_code_discussions_discussion_id_reject_suggested_edit_post(configuration: &configuration::Configuration, project: &str, discussion_id: &str) -> Result<(), Error<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdRejectSuggestedEditPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/code-discussions/{discussionId}/reject-suggested-edit", local_var_configuration.base_path, project=crate::apis::urlencode(project), discussionId=crate::apis::urlencode(discussion_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdRejectSuggestedEditPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_code_discussions_discussion_id_reopen_suggested_edit_post(configuration: &configuration::Configuration, project: &str, discussion_id: &str) -> Result<(), Error<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdReopenSuggestedEditPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/code-discussions/{discussionId}/reopen-suggested-edit", local_var_configuration.base_path, project=crate::apis::urlencode(project), discussionId=crate::apis::urlencode(discussion_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdReopenSuggestedEditPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_code_discussions_discussion_id_suggested_edit_patch(configuration: &configuration::Configuration, project: &str, discussion_id: &str, projects_project_code_reviews_code_discussions_discussion_id_suggested_edit_patch_request: crate::models::ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdSuggestedEditPatchRequest) -> Result<(), Error<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdSuggestedEditPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/code-discussions/{discussionId}/suggested-edit", local_var_configuration.base_path, project=crate::apis::urlencode(project), discussionId=crate::apis::urlencode(discussion_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_code_discussions_discussion_id_suggested_edit_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCodeDiscussionsDiscussionIdSuggestedEditPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_code_discussions_post(configuration: &configuration::Configuration, project: &str, projects_project_code_reviews_code_discussions_post_request: crate::models::ProjectsProjectCodeReviewsCodeDiscussionsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CodeDiscussionRecord, Error<ProjectsProjectCodeReviewsCodeDiscussionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/code-discussions", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_code_discussions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCodeDiscussionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_commit_set_review_post(configuration: &configuration::Configuration, project: &str, projects_project_code_reviews_commit_set_review_post_request: crate::models::ProjectsProjectCodeReviewsCommitSetReviewPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CommitSetReviewRecord, Error<ProjectsProjectCodeReviewsCommitSetReviewPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/commit-set-review", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_commit_set_review_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsCommitSetReviewPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, state: Option<CodeReviewStateFilter>, text: Option<&str>, author: Option<&str>, from: Option<&str>, to: Option<&str>, sort: Option<ReviewSorting>, reviewer: Option<&str>, r#type: Option<ReviewType>, repository: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectCodeReviewsGet200Response, Error<ProjectsProjectCodeReviewsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder = local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = text {
        local_var_req_builder = local_var_req_builder.query(&[("text", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = author {
        local_var_req_builder = local_var_req_builder.query(&[("author", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reviewer {
        local_var_req_builder = local_var_req_builder.query(&[("reviewer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = repository {
        local_var_req_builder = local_var_req_builder.query(&[("repository", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_merge_requests_post(configuration: &configuration::Configuration, project: &str, projects_project_code_reviews_merge_requests_post_request: crate::models::ProjectsProjectCodeReviewsMergeRequestsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::MergeRequestRecord, Error<ProjectsProjectCodeReviewsMergeRequestsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/merge-requests", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_merge_requests_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsMergeRequestsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_description_patch(configuration: &configuration::Configuration, project: &str, review_id: &str, chats_channels_channel_description_patch_request: crate::models::ChatsChannelsChannelDescriptionPatchRequest) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdDescriptionPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/description", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_description_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdDescriptionPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_details_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::CodeReviewDetailedInfo, Error<ProjectsProjectCodeReviewsReviewIdDetailsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/details", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdDetailsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List files changed in commits under code review
pub async fn projects_project_code_reviews_review_id_files_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectCodeReviewsReviewIdFilesGet200Response, Error<ProjectsProjectCodeReviewsReviewIdFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/files", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::CodeReviewRecord, Error<ProjectsProjectCodeReviewsReviewIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_make_read_only_patch(configuration: &configuration::Configuration, project: &str, review_id: &str) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdMakeReadOnlyPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/make-read-only", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdMakeReadOnlyPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List files in merge request which will be merged into target branch
pub async fn projects_project_code_reviews_review_id_merge_files_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectCodeReviewsReviewIdMergeFilesGet200Response, Error<ProjectsProjectCodeReviewsReviewIdMergeFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/merge-files", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdMergeFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_merge_put(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_merge_put_request: crate::models::ProjectsProjectCodeReviewsReviewIdMergePutRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitMergeResultHttp, Error<ProjectsProjectCodeReviewsReviewIdMergePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/merge", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_merge_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdMergePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_participants_user_delete(configuration: &configuration::Configuration, project: &str, review_id: &str, user: &str, role: CodeReviewParticipantRole) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdParticipantsUserDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/participants/{user}", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id), user=crate::apis::urlencode(user));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("role", &role.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdParticipantsUserDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_participants_user_post(configuration: &configuration::Configuration, project: &str, review_id: &str, user: &str, projects_project_code_reviews_review_id_participants_user_post_request: crate::models::ProjectsProjectCodeReviewsReviewIdParticipantsUserPostRequest) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdParticipantsUserPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/participants/{user}", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id), user=crate::apis::urlencode(user));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_participants_user_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdParticipantsUserPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_rebase_put(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_rebase_put_request: crate::models::ProjectsProjectCodeReviewsReviewIdRebasePutRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitRebaseResultHttp, Error<ProjectsProjectCodeReviewsReviewIdRebasePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/rebase", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_rebase_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdRebasePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_revisions_delete(configuration: &configuration::Configuration, project: &str, review_id: &str, revisions: Vec<String>) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdRevisionsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/revisions", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&revisions.into_iter().map(|p| ("revisions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("revisions", &revisions.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdRevisionsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_revisions_post(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_revisions_post_request: crate::models::ProjectsProjectCodeReviewsReviewIdRevisionsPostRequest) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdRevisionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/revisions", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_revisions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdRevisionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_state_patch(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_state_patch_request: crate::models::ProjectsProjectCodeReviewsReviewIdStatePatchRequest) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdStatePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/state", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_state_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdStatePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_suggested_reviewers_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<ProjectsProjectCodeReviewsReviewIdSuggestedReviewersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/suggested-reviewers", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdSuggestedReviewersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_title_patch(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_title_patch_request: crate::models::ProjectsProjectCodeReviewsReviewIdTitlePatchRequest) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdTitlePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/title", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_title_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdTitlePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_unbound_discussions_discussion_id_toggle_patch(configuration: &configuration::Configuration, project: &str, review_id: &str, discussion_id: &str, projects_project_code_reviews_review_id_unbound_discussions_discussion_id_toggle_patch_request: Option<crate::models::ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsDiscussionIdTogglePatchRequest>) -> Result<(), Error<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsDiscussionIdTogglePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/unbound-discussions/{discussionId}/toggle", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id), discussionId=crate::apis::urlencode(discussion_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_unbound_discussions_discussion_id_toggle_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsDiscussionIdTogglePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_unbound_discussions_get(configuration: &configuration::Configuration, project: &str, review_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsGet200Response, Error<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/unbound-discussions", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_review_id_unbound_discussions_post(configuration: &configuration::Configuration, project: &str, review_id: &str, projects_project_code_reviews_review_id_unbound_discussions_post_request: crate::models::ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::CodeReviewUnboundDiscussionRecord, Error<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/{reviewId}/unbound-discussions", local_var_configuration.base_path, project=crate::apis::urlencode(project), reviewId=crate::apis::urlencode(review_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_review_id_unbound_discussions_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsReviewIdUnboundDiscussionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_safe_merge_delete(configuration: &configuration::Configuration, project: &str, merge_request_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SafeMergeMessage>, Error<ProjectsProjectCodeReviewsSafeMergeDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/safe-merge", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("mergeRequestId", &merge_request_id.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsSafeMergeDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_safe_merge_get(configuration: &configuration::Configuration, project: &str, merge_request_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::SafeMerge, Error<ProjectsProjectCodeReviewsSafeMergeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/safe-merge", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("mergeRequestId", &merge_request_id.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsSafeMergeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_code_reviews_safe_merge_post(configuration: &configuration::Configuration, project: &str, projects_project_code_reviews_safe_merge_post_request: crate::models::ProjectsProjectCodeReviewsSafeMergePostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SafeMergeMessage>, Error<ProjectsProjectCodeReviewsSafeMergePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/code-reviews/safe-merge", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_code_reviews_safe_merge_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectCodeReviewsSafeMergePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a project
pub async fn projects_project_delete(configuration: &configuration::Configuration, project: &str) -> Result<(), Error<ProjectsProjectDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_access_get(configuration: &configuration::Configuration, project: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::DocumentAccess, Error<ProjectsProjectDocumentsDocumentIdAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_access_patch(configuration: &configuration::Configuration, project: &str, document_id: &str, projects_project_documents_document_id_access_patch_request: crate::models::ProjectsProjectDocumentsDocumentIdAccessPatchRequest) -> Result<(), Error<ProjectsProjectDocumentsDocumentIdAccessPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_access_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdAccessPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_copy_post(configuration: &configuration::Configuration, project: &str, document_id: &str, projects_project_documents_document_id_copy_post_request: crate::models::ProjectsProjectDocumentsDocumentIdCopyPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsDocumentIdCopyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}/copy", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_copy_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdCopyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_delete(configuration: &configuration::Configuration, project: &str, document_id: &str) -> Result<(), Error<ProjectsProjectDocumentsDocumentIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_get(configuration: &configuration::Configuration, project: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsDocumentIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_move_patch(configuration: &configuration::Configuration, project: &str, document_id: &str, projects_project_documents_document_id_move_patch_request: crate::models::ProjectsProjectDocumentsDocumentIdMovePatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsDocumentIdMovePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}/move", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_move_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdMovePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_patch(configuration: &configuration::Configuration, project: &str, document_id: &str, dollar_fields: Option<&str>, projects_project_documents_document_id_patch_request: Option<crate::models::ProjectsProjectDocumentsDocumentIdPatchRequest>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsDocumentIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_document_id_unarchive_patch(configuration: &configuration::Configuration, project: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsDocumentIdUnarchivePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/{documentId}/unarchive", local_var_configuration.base_path, project=crate::apis::urlencode(project), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsDocumentIdUnarchivePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_access_get(configuration: &configuration::Configuration, project: &str, folder: &str, dollar_fields: Option<&str>) -> Result<crate::models::FolderAccess, Error<ProjectsProjectDocumentsFoldersFolderAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_access_patch(configuration: &configuration::Configuration, project: &str, folder: &str, projects_project_documents_folders_folder_access_patch_request: crate::models::ProjectsProjectDocumentsFoldersFolderAccessPatchRequest) -> Result<(), Error<ProjectsProjectDocumentsFoldersFolderAccessPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_folder_access_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderAccessPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_delete(configuration: &configuration::Configuration, project: &str, folder: &str) -> Result<(), Error<ProjectsProjectDocumentsFoldersFolderDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_documents_get(configuration: &configuration::Configuration, project: &str, folder: &str, with_archived: Option<bool>, sort_by: Option<&str>, order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderDocumentsGet200Response, Error<ProjectsProjectDocumentsFoldersFolderDocumentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/documents", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderDocumentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_get(configuration: &configuration::Configuration, project: &str, folder: &str, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<ProjectsProjectDocumentsFoldersFolderGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_introduction_delete(configuration: &configuration::Configuration, project: &str, folder: &str) -> Result<(), Error<ProjectsProjectDocumentsFoldersFolderIntroductionDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/introduction", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderIntroductionDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_introduction_document_id_patch(configuration: &configuration::Configuration, project: &str, folder: &str, document_id: &str) -> Result<(), Error<ProjectsProjectDocumentsFoldersFolderIntroductionDocumentIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/introduction/{documentId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderIntroductionDocumentIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_move_patch(configuration: &configuration::Configuration, project: &str, folder: &str, projects_project_documents_folders_folder_move_patch_request: crate::models::ProjectsProjectDocumentsFoldersFolderMovePatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<ProjectsProjectDocumentsFoldersFolderMovePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/move", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_folder_move_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderMovePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_patch(configuration: &configuration::Configuration, project: &str, folder: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest) -> Result<(), Error<ProjectsProjectDocumentsFoldersFolderPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Executes search for project documents and folders in specified folder
pub async fn projects_project_documents_folders_folder_search_get(configuration: &configuration::Configuration, project: &str, folder: &str, query: &str, include_body: Option<bool>, folders_only: Option<bool>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderSearchGet200Response, Error<ProjectsProjectDocumentsFoldersFolderSearchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/search", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = include_body {
        local_var_req_builder = local_var_req_builder.query(&[("includeBody", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = folders_only {
        local_var_req_builder = local_var_req_builder.query(&[("foldersOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_folder_subfolders_get(configuration: &configuration::Configuration, project: &str, folder: &str, with_archived: Option<bool>, sort_by: Option<&str>, order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderSubfoldersGet200Response, Error<ProjectsProjectDocumentsFoldersFolderSubfoldersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders/{folder}/subfolders", local_var_configuration.base_path, project=crate::apis::urlencode(project), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersFolderSubfoldersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_folders_post(configuration: &configuration::Configuration, project: &str, projects_project_documents_folders_post_request: crate::models::ProjectsProjectDocumentsFoldersPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<ProjectsProjectDocumentsFoldersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents/folders", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsFoldersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_documents_post(configuration: &configuration::Configuration, project: &str, projects_project_documents_post_request: crate::models::ProjectsProjectDocumentsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<ProjectsProjectDocumentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/documents", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectDocumentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update list of project items pinned for the project by default
pub async fn projects_project_feature_pins_patch(configuration: &configuration::Configuration, project: &str, projects_project_feature_pins_patch_request: crate::models::ProjectsProjectFeaturePinsPatchRequest) -> Result<(), Error<ProjectsProjectFeaturePinsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/feature-pins", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_feature_pins_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectFeaturePinsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get project by ID or project key
pub async fn projects_project_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<crate::models::PrProject, Error<ProjectsProjectGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of package repositories for a given project ID
pub async fn projects_project_packages_repositories_get(configuration: &configuration::Configuration, project: &str, r#type: Option<&str>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ProjectPackageRepository>, Error<ProjectsProjectPackagesRepositoriesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a new package repository for a given project ID
pub async fn projects_project_packages_repositories_post(configuration: &configuration::Configuration, project: &str, projects_project_packages_repositories_post_request: crate::models::ProjectsProjectPackagesRepositoriesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::ProjectPackageRepository, Error<ProjectsProjectPackagesRepositoriesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates package repository settings for a given project ID
pub async fn projects_project_packages_repositories_repository_access_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::PackagesAccess, Error<ProjectsProjectPackagesRepositoriesRepositoryAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates package repository settings for a given project ID
pub async fn projects_project_packages_repositories_repository_access_patch(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_packages_repositories_repository_access_patch_request: crate::models::ProjectsProjectPackagesRepositoriesRepositoryAccessPatchRequest) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryAccessPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/access", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_access_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryAccessPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Dry run of cleanup for specified package repository
pub async fn projects_project_packages_repositories_repository_cleanup_dry_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_packages_repositories_repository_cleanup_dry_post_request: crate::models::ProjectsProjectPackagesRepositoriesRepositoryCleanupDryPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DryCleanupResults, Error<ProjectsProjectPackagesRepositoriesRepositoryCleanupDryPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/cleanup/dry", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_cleanup_dry_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryCleanupDryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cleanup specified package repository
pub async fn projects_project_packages_repositories_repository_cleanup_post(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>, projects_project_packages_repositories_repository_cleanup_post_request: Option<crate::models::ProjectsProjectPackagesRepositoriesRepositoryCleanupPostRequest>) -> Result<crate::models::PackagesExecutionResult, Error<ProjectsProjectPackagesRepositoriesRepositoryCleanupPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/cleanup", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_cleanup_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryCleanupPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get list of publishing to remote repository
pub async fn projects_project_packages_repositories_repository_connections_connection_id_publish_get(configuration: &configuration::Configuration, project: &str, repository: &str, connection_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishGet200Response, Error<ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/connections/{connectionId}/publish", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), connectionId=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Publishes packages to remote repository
pub async fn projects_project_packages_repositories_repository_connections_connection_id_publish_post(configuration: &configuration::Configuration, project: &str, repository: &str, connection_id: &str, projects_project_packages_repositories_repository_connections_connection_id_publish_post_request: crate::models::ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishPostRequest) -> Result<String, Error<ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/connections/{connectionId}/publish", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), connectionId=crate::apis::urlencode(connection_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_connections_connection_id_publish_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryConnectionsConnectionIdPublishPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of remote package repositories for given project
pub async fn projects_project_packages_repositories_repository_connections_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PackageRepositoryConnection>, Error<ProjectsProjectPackagesRepositoriesRepositoryConnectionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/connections", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryConnectionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes package repository for a given project ID
pub async fn projects_project_packages_repositories_repository_delete(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a folder in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_files_folderfolder_path_delete(configuration: &configuration::Configuration, project: &str, repository: &str, folder_path: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryFilesFolderfolderPathDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/files/folder:{folderPath}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), folderPath=crate::apis::urlencode(folder_path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryFilesFolderfolderPathDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of repository files for a given project ID in parent folder
pub async fn projects_project_packages_repositories_repository_files_get(configuration: &configuration::Configuration, project: &str, repository: &str, parent_path: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::FileData>, Error<ProjectsProjectPackagesRepositoriesRepositoryFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/files", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = parent_path {
        local_var_req_builder = local_var_req_builder.query(&[("parentPath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a file in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_files_namefile_path_delete(configuration: &configuration::Configuration, project: &str, repository: &str, file_path: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/files/name:{filePath}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), filePath=crate::apis::urlencode(file_path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a details for repository file for a given project ID
pub async fn projects_project_packages_repositories_repository_files_namefile_path_get(configuration: &configuration::Configuration, project: &str, repository: &str, file_path: &str, dollar_fields: Option<&str>) -> Result<crate::models::FileDetails, Error<ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/files/name:{filePath}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), filePath=crate::apis::urlencode(file_path));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryFilesNamefilePathGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a package repository for a given project ID by type and name
pub async fn projects_project_packages_repositories_repository_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::ProjectPackageRepository, Error<ProjectsProjectPackagesRepositoriesRepositoryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of repository packages for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_get(configuration: &configuration::Configuration, project: &str, repository: &str, query: &str, connection_id: Option<&str>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesGet200Response, Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = connection_id {
        local_var_req_builder = local_var_req_builder.query(&[("connectionId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes all package versions in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_delete(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get package metadata in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_metadata_get(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, dollar_fields: Option<&str>) -> Result<crate::models::PackageMetadata, Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/metadata", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a package metadata in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_metadata_put(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, projects_project_packages_repositories_repository_packages_name_package_name_metadata_put_request: Option<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesNamePackageNameMetadataPutRequest>) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/metadata", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_packages_name_package_name_metadata_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Report a package version metadata in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_metadata_versionpackage_version_put(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, package_version: &str, projects_project_packages_repositories_repository_packages_name_package_name_metadata_version_package_version_put_request: crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesNamePackageNameMetadataVersionPackageVersionPutRequest) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataVersionpackageVersionPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/metadata/version:{packageVersion}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name), packageVersion=crate::apis::urlencode(package_version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_packages_name_package_name_metadata_version_package_version_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameMetadataVersionpackageVersionPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of repository package versions for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_versions_get(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, query: &str, sort_column: PackagesSortColumn, sort_order: ColumnSortOrder, connection_id: Option<&str>, pinned: Option<bool>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesNamePackageNameVersionsGet200Response, Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/versions", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = connection_id {
        local_var_req_builder = local_var_req_builder.query(&[("connectionId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pinned {
        local_var_req_builder = local_var_req_builder.query(&[("pinned", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("sortColumn", &sort_column.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &sort_order.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a package version in repository for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_versions_versionpackage_version_delete(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, package_version: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/versions/version:{packageVersion}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name), packageVersion=crate::apis::urlencode(package_version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a details for repository package version for a given project ID
pub async fn projects_project_packages_repositories_repository_packages_namepackage_name_versions_versionpackage_version_get(configuration: &configuration::Configuration, project: &str, repository: &str, package_name: &str, package_version: &str, dollar_fields: Option<&str>) -> Result<crate::models::PackageVersionDetails, Error<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/packages/name:{packageName}/versions/version:{packageVersion}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), packageName=crate::apis::urlencode(package_name), packageVersion=crate::apis::urlencode(package_version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPackagesNamepackageNameVersionsVersionpackageVersionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates package repository settings for a given project ID
pub async fn projects_project_packages_repositories_repository_patch(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_packages_repositories_repository_patch_request: Option<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPatchRequest>) -> Result<(), Error<ProjectsProjectPackagesRepositoriesRepositoryPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_packages_repositories_repository_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a package repository URL for a given project ID
pub async fn projects_project_packages_repositories_repository_url_get(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<String, Error<ProjectsProjectPackagesRepositoriesRepositoryUrlGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/{repository}/url", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesRepositoryUrlGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of repository packages for a given project ID
pub async fn projects_project_packages_repositories_typetype_repositoryrepository_name_packages_get(configuration: &configuration::Configuration, project: &str, r#type: &str, repository_name: &str, query: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesGet200Response, Error<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/type:{type}/repository:{repositoryName}/packages", local_var_configuration.base_path, project=crate::apis::urlencode(project), type=crate::apis::urlencode(r#type), repositoryName=crate::apis::urlencode(repository_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of repository package versions for a given project ID
pub async fn projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_get(configuration: &configuration::Configuration, project: &str, r#type: &str, repository_name: &str, package_name: &str, query: &str, sort_column: PackagesSortColumn, sort_order: ColumnSortOrder, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesNamePackageNameVersionsGet200Response, Error<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/type:{type}/repository:{repositoryName}/packages/name:{packageName}/versions", local_var_configuration.base_path, project=crate::apis::urlencode(project), type=crate::apis::urlencode(r#type), repositoryName=crate::apis::urlencode(repository_name), packageName=crate::apis::urlencode(package_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("sortColumn", &sort_column.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("sortOrder", &sort_order.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes a package version in repository for a given project ID
pub async fn projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_versionpackage_version_delete(configuration: &configuration::Configuration, project: &str, r#type: &str, repository_name: &str, package_name: &str, package_version: &str) -> Result<(), Error<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/type:{type}/repository:{repositoryName}/packages/name:{packageName}/versions/version:{packageVersion}", local_var_configuration.base_path, project=crate::apis::urlencode(project), type=crate::apis::urlencode(r#type), repositoryName=crate::apis::urlencode(repository_name), packageName=crate::apis::urlencode(package_name), packageVersion=crate::apis::urlencode(package_version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a details for repository package version for a given project ID
pub async fn projects_project_packages_repositories_typetype_repositoryrepository_name_packages_namepackage_name_versions_versionpackage_version_get(configuration: &configuration::Configuration, project: &str, r#type: &str, repository_name: &str, package_name: &str, package_version: &str, dollar_fields: Option<&str>) -> Result<crate::models::PackageVersionDetails, Error<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/repositories/type:{type}/repository:{repositoryName}/packages/name:{packageName}/versions/version:{packageVersion}", local_var_configuration.base_path, project=crate::apis::urlencode(project), type=crate::apis::urlencode(r#type), repositoryName=crate::apis::urlencode(repository_name), packageName=crate::apis::urlencode(package_name), packageVersion=crate::apis::urlencode(package_version));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesRepositoriesTypetypeRepositoryrepositoryNamePackagesNamepackageNameVersionsVersionpackageVersionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Executes a package search for a given project ID
pub async fn projects_project_packages_search_get(configuration: &configuration::Configuration, project: &str, r#type: &str, query: &str, connection_id: Option<&str>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPackagesRepositoriesRepositoryPackagesNamePackageNameVersionsGet200Response, Error<ProjectsProjectPackagesSearchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/search", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = connection_id {
        local_var_req_builder = local_var_req_builder.query(&[("connectionId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of available repository types.
pub async fn projects_project_packages_types_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PackageType>, Error<ProjectsProjectPackagesTypesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/packages/types", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPackagesTypesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing project. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn projects_project_patch(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>, projects_project_patch_request: Option<crate::models::ProjectsProjectPatchRequest>) -> Result<crate::models::PrProject, Error<ProjectsProjectPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns project participants by provided profiles
pub async fn projects_project_people_members_by_ids_get(configuration: &configuration::Configuration, project: &str, profiles: Vec<String>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ParticipantOnProject>, Error<ProjectsProjectPeopleMembersByIdsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/members/by-ids", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&profiles.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("profiles", &profiles.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleMembersByIdsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all project participants
pub async fn projects_project_people_members_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, role: Option<&str>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPeopleMembersGet200Response, Error<ProjectsProjectPeopleMembersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/members", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleMembersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes participant
pub async fn projects_project_people_members_profile_delete(configuration: &configuration::Configuration, project: &str, profile: &str) -> Result<(), Error<ProjectsProjectPeopleMembersProfileDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/members/{profile}", local_var_configuration.base_path, project=crate::apis::urlencode(project), profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleMembersProfileDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Adds or removes project participant roles
pub async fn projects_project_people_members_update_post(configuration: &configuration::Configuration, project: &str, projects_project_people_members_update_post_request: crate::models::ProjectsProjectPeopleMembersUpdatePostRequest) -> Result<(), Error<ProjectsProjectPeopleMembersUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/members/update", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_people_members_update_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleMembersUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns project participant teams by provided teams
pub async fn projects_project_people_teams_by_ids_get(configuration: &configuration::Configuration, project: &str, teams: Vec<String>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ParticipantTeamOnProject>, Error<ProjectsProjectPeopleTeamsByIdsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/teams/by-ids", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&teams.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("teams", &teams.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleTeamsByIdsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all project participant teams
pub async fn projects_project_people_teams_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, role: Option<&str>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPeopleTeamsGet200Response, Error<ProjectsProjectPeopleTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/teams", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Removes participant
pub async fn projects_project_people_teams_team_delete(configuration: &configuration::Configuration, project: &str, team: &str) -> Result<(), Error<ProjectsProjectPeopleTeamsTeamDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/teams/{team}", local_var_configuration.base_path, project=crate::apis::urlencode(project), team=crate::apis::urlencode(team));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleTeamsTeamDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Adds or removes project team participant roles
pub async fn projects_project_people_teams_update_post(configuration: &configuration::Configuration, project: &str, projects_project_people_teams_update_post_request: crate::models::ProjectsProjectPeopleTeamsUpdatePostRequest) -> Result<(), Error<ProjectsProjectPeopleTeamsUpdatePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/people/teams/update", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_people_teams_update_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPeopleTeamsUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update list of project items pinned for the project personally for you
pub async fn projects_project_personal_feature_pins_patch(configuration: &configuration::Configuration, project: &str, projects_project_personal_feature_pins_patch_request: crate::models::ProjectsProjectPersonalFeaturePinsPatchRequest) -> Result<(), Error<ProjectsProjectPersonalFeaturePinsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/personal-feature-pins", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_personal_feature_pins_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPersonalFeaturePinsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive an existing board. This operation can be performed by board owners or other members who are granted permission to manage boards in a project.
pub async fn projects_project_planning_boards_board_archive_delete(configuration: &configuration::Configuration, project: &str, board: &str) -> Result<(), Error<ProjectsProjectPlanningBoardsBoardArchiveDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/boards/{board}/archive", local_var_configuration.base_path, project=crate::apis::urlencode(project), board=crate::apis::urlencode(board));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningBoardsBoardArchiveDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search existing boards in a project
pub async fn projects_project_planning_boards_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPlanningBoardsGet200Response, Error<ProjectsProjectPlanningBoardsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/boards", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningBoardsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new issue board in a project. The user will become the owner of the board.
pub async fn projects_project_planning_boards_post(configuration: &configuration::Configuration, project: &str, projects_project_planning_boards_post_request: crate::models::ProjectsProjectPlanningBoardsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::BoardRecord, Error<ProjectsProjectPlanningBoardsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/boards", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_boards_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningBoardsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search existing sprints in a project
pub async fn projects_project_planning_boards_sprints_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, board: Option<&str>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPlanningBoardsSprintsGet200Response, Error<ProjectsProjectPlanningBoardsSprintsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/boards/sprints", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = board {
        local_var_req_builder = local_var_req_builder.query(&[("board", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningBoardsSprintsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all starred boards in a project
pub async fn projects_project_planning_boards_starred_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BoardRecord>, Error<ProjectsProjectPlanningBoardsStarredGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/boards/starred", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningBoardsStarredGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing checklist in a project
pub async fn projects_project_planning_checklists_checklist_id_delete(configuration: &configuration::Configuration, project: &str, checklist_id: &str) -> Result<(), Error<ProjectsProjectPlanningChecklistsChecklistIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/{checklistId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsChecklistIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the content of a checklist in a project
pub async fn projects_project_planning_checklists_checklist_id_full_checklist_tree_get(configuration: &configuration::Configuration, project: &str, checklist_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PlanItemChildren>, Error<ProjectsProjectPlanningChecklistsChecklistIdFullChecklistTreeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/{checklistId}/full-checklist-tree", local_var_configuration.base_path, project=crate::apis::urlencode(project), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsChecklistIdFullChecklistTreeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Tab indented lines are converted into checkable items following the same rules as in Import Checklist. The result is placed inside of the specified project checklist.
pub async fn projects_project_planning_checklists_checklist_id_import_post(configuration: &configuration::Configuration, project: &str, checklist_id: &str, projects_project_planning_checklists_checklist_id_import_post_request: crate::models::ProjectsProjectPlanningChecklistsChecklistIdImportPostRequest) -> Result<(), Error<ProjectsProjectPlanningChecklistsChecklistIdImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/{checklistId}/import", local_var_configuration.base_path, project=crate::apis::urlencode(project), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_checklists_checklist_id_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsChecklistIdImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing checklist in a project
pub async fn projects_project_planning_checklists_checklist_id_patch(configuration: &configuration::Configuration, project: &str, checklist_id: &str, projects_project_planning_checklists_checklist_id_patch_request: Option<crate::models::ProjectsProjectPlanningChecklistsChecklistIdPatchRequest>) -> Result<(), Error<ProjectsProjectPlanningChecklistsChecklistIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/{checklistId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_checklists_checklist_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsChecklistIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search existing checklists in a project
pub async fn projects_project_planning_checklists_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, sorting: Option<ChecklistSorting>, descending: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPlanningChecklistsGet200Response, Error<ProjectsProjectPlanningChecklistsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sorting {
        local_var_req_builder = local_var_req_builder.query(&[("sorting", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = descending {
        local_var_req_builder = local_var_req_builder.query(&[("descending", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new checklist in a project using tab indented lines as checkable items. The items with the same indent level will be placed one under the other. An issue URL will be converted into the corresponding issue.
pub async fn projects_project_planning_checklists_import_post(configuration: &configuration::Configuration, project: &str, projects_project_planning_checklists_import_post_request: crate::models::ProjectsProjectPlanningChecklistsImportPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Checklist, Error<ProjectsProjectPlanningChecklistsImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/import", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_checklists_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new checklist in a project
pub async fn projects_project_planning_checklists_post(configuration: &configuration::Configuration, project: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Checklist, Error<ProjectsProjectPlanningChecklistsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all starred checklists in a project
pub async fn projects_project_planning_checklists_starred_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::Checklist>, Error<ProjectsProjectPlanningChecklistsStarredGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/checklists/starred", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningChecklistsStarredGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Query order for built-in issue fields
pub async fn projects_project_planning_issues_fields_order_get(configuration: &configuration::Configuration, project: &str, only_visible: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TrackerIssueFieldOrder, Error<ProjectsProjectPlanningIssuesFieldsOrderGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/fields/order", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = only_visible {
        local_var_req_builder = local_var_req_builder.query(&[("onlyVisible", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesFieldsOrderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Query order for built-in issue fields
pub async fn projects_project_planning_issues_fields_order_patch(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_fields_order_patch_request: crate::models::ProjectsProjectPlanningIssuesFieldsOrderPatchRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesFieldsOrderPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/fields/order", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_fields_order_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesFieldsOrderPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Query visibility for built-in issue fields
pub async fn projects_project_planning_issues_fields_visibility_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<crate::models::TrackerIssueFieldVisibility, Error<ProjectsProjectPlanningIssuesFieldsVisibilityGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/fields/visibility", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesFieldsVisibilityGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set visibility for a built-in issue field
pub async fn projects_project_planning_issues_fields_visibility_patch(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_fields_visibility_patch_request: crate::models::ProjectsProjectPlanningIssuesFieldsVisibilityPatchRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesFieldsVisibilityPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/fields/visibility", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_fields_visibility_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesFieldsVisibilityPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search existing issues in a project. Parameters are applied as 'AND' filters.
pub async fn projects_project_planning_issues_get(configuration: &configuration::Configuration, project: &str, sorting: IssuesSorting, descending: bool, dollar_skip: Option<&str>, dollar_top: Option<i32>, assignee_id: Option<Vec<String>>, created_by_profile_id: Option<&str>, created_by: Option<Vec<String>>, statuses: Option<Vec<String>>, tag_id: Option<&str>, query: Option<&str>, tags: Option<Vec<String>>, sprints: Option<Vec<String>>, boards: Option<Vec<String>>, custom_fields: Option<Vec<String>>, import_transaction: Option<&str>, creation_time_from: Option<String>, creation_time_to: Option<String>, due_date_from: Option<&str>, due_date_to: Option<&str>, topics: Option<Vec<String>>, grouping: Option<IssueListGrouping>, deployment: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsPlanningBoardsSprintsSprintIssuesGet200Response, Error<ProjectsProjectPlanningIssuesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = assignee_id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("assigneeId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("assigneeId", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = created_by_profile_id {
        local_var_req_builder = local_var_req_builder.query(&[("createdByProfileId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = created_by {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("createdBy".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("createdBy", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = statuses {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("statuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("statuses", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = tag_id {
        local_var_req_builder = local_var_req_builder.query(&[("tagId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("sorting", &sorting.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("descending", &descending.to_string())]);
    if let Some(ref local_var_str) = tags {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("tags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("tags", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = sprints {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sprints".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("sprints", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = boards {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("boards".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("boards", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = custom_fields {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("customFields".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("customFields", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = import_transaction {
        local_var_req_builder = local_var_req_builder.query(&[("importTransaction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = creation_time_from {
        local_var_req_builder = local_var_req_builder.query(&[("creationTimeFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = creation_time_to {
        local_var_req_builder = local_var_req_builder.query(&[("creationTimeTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = due_date_from {
        local_var_req_builder = local_var_req_builder.query(&[("dueDateFrom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = due_date_to {
        local_var_req_builder = local_var_req_builder.query(&[("dueDateTo", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = topics {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("topics".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("topics", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = grouping {
        local_var_req_builder = local_var_req_builder.query(&[("grouping", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = deployment {
        local_var_req_builder = local_var_req_builder.query(&[("deployment", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Import issues in a project
pub async fn projects_project_planning_issues_import_post(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_import_post_request: crate::models::ProjectsProjectPlanningIssuesImportPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::IssueImportResult, Error<ProjectsProjectPlanningIssuesImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/import", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove attachment from an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_attachment_attachment_id_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, attachment_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdAttachmentAttachmentIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/attachment/{attachmentId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id), attachmentId=crate::apis::urlencode(attachment_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdAttachmentAttachmentIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add attachment to an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_attachment_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_attachment_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdAttachmentPostRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdAttachmentPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/attachment", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_attachment_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdAttachmentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove attachments from an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_attachments_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, identities: Vec<String>) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdAttachmentsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/attachments", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&identities.into_iter().map(|p| ("identities".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("identities", &identities.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdAttachmentsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add attachments to an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_attachments_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_attachments_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdAttachmentsPostRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdAttachmentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/attachments", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_attachments_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdAttachmentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove the checklist from an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_checklists_checklist_id_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, checklist_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/checklists/{checklistId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add the checklist to an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_checklists_checklist_id_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, checklist_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/checklists/{checklistId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdChecklistsChecklistIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove code review links from an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_code_reviews_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, code_review_ids: Vec<String>) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdCodeReviewsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/code-reviews", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&code_review_ids.into_iter().map(|p| ("codeReviewIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("codeReviewIds", &code_review_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdCodeReviewsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add code review links to an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_code_reviews_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_code_reviews_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdCodeReviewsPostRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdCodeReviewsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/code-reviews", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_code_reviews_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdCodeReviewsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_planning_issues_issue_id_comments_import_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_comments_import_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdCommentsImportPostRequest) -> Result<Vec<String>, Error<ProjectsProjectPlanningIssuesIssueIdCommentsImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/comments/import", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_comments_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdCommentsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove commit links from an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_commits_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, repository: &str, commit_ids: Vec<String>) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdCommitsDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/commits", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("repository", &repository.to_string())]);
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&commit_ids.into_iter().map(|p| ("commitIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("commitIds", &commit_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdCommitsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add commit links to an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_commits_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_commits_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdCommitsPostRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdCommitsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/commits", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_commits_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdCommitsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an issue from a project
pub async fn projects_project_planning_issues_issue_id_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve issue by identifier. To retrieve multiple issues at once, use [Get issues by identifiers](/extensions/httpApiPlayground?resource=issues&parent-resource=issues&endpoint=http_post_get-by-ids) (`/issues/get-by-ids`)
pub async fn projects_project_planning_issues_issue_id_get(configuration: &configuration::Configuration, project: &str, issue_id: &str, with_deleted: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::Issue, Error<ProjectsProjectPlanningIssuesIssueIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_deleted {
        local_var_req_builder = local_var_req_builder.query(&[("withDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing issue in a project
pub async fn projects_project_planning_issues_issue_id_patch(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_patch_request: Option<crate::models::ProjectsProjectPlanningIssuesIssueIdPatchRequest>) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore an issue in a project
pub async fn projects_project_planning_issues_issue_id_restore_post(configuration: &configuration::Configuration, project: &str, issue_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/restore", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an existing tag from an issue in a project
pub async fn projects_project_planning_issues_issue_id_tags_tag_id_delete(configuration: &configuration::Configuration, project: &str, issue_id: &str, tag_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdTagsTagIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/tags/{tagId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id), tagId=crate::apis::urlencode(tag_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdTagsTagIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add an existing tag to an issue in a project
pub async fn projects_project_planning_issues_issue_id_tags_tag_id_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, tag_id: &str) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdTagsTagIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/tags/{tagId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id), tagId=crate::apis::urlencode(tag_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdTagsTagIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Toggle status of an existing issue between resolved and unresolved
pub async fn projects_project_planning_issues_issue_id_toggle_resolved_post(configuration: &configuration::Configuration, project: &str, issue_id: &str, projects_project_planning_issues_issue_id_toggle_resolved_post_request: crate::models::ProjectsProjectPlanningIssuesIssueIdToggleResolvedPostRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesIssueIdToggleResolvedPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/{issueId}/toggle-resolved", local_var_configuration.base_path, project=crate::apis::urlencode(project), issueId=crate::apis::urlencode(issue_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_issue_id_toggle_resolved_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesIssueIdToggleResolvedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Find an existing issue by a given number in a project
pub async fn projects_project_planning_issues_numbernumber_get(configuration: &configuration::Configuration, project: &str, number: i32, resolve_alias: Option<bool>, with_deleted: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::Issue, Error<ProjectsProjectPlanningIssuesNumbernumberGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/number:{number}", local_var_configuration.base_path, project=crate::apis::urlencode(project), number=number);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = resolve_alias {
        local_var_req_builder = local_var_req_builder.query(&[("resolveAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_deleted {
        local_var_req_builder = local_var_req_builder.query(&[("withDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesNumbernumberGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new issue in a project
pub async fn projects_project_planning_issues_post(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_post_request: crate::models::ProjectsProjectPlanningIssuesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Issue, Error<ProjectsProjectPlanningIssuesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get target issue status for auto updating issues on linked merge request merge
pub async fn projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<crate::models::IssueStatus, Error<ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/statuses/auto-update-on-merge-request-merge", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set target issue status for auto updating issues on linked merge request merge
pub async fn projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_patch(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_patch_request: Option<crate::models::ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergePatchRequest>) -> Result<(), Error<ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/statuses/auto-update-on-merge-request-merge", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_statuses_auto_update_on_merge_request_merge_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesStatusesAutoUpdateOnMergeRequestMergePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all existing issue statuses with their usage, number of existing issues, in a project
pub async fn projects_project_planning_issues_statuses_distribution_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::IssueStatusWithUsages>, Error<ProjectsProjectPlanningIssuesStatusesDistributionGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/statuses/distribution", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesStatusesDistributionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all existing issue statuses in a project
pub async fn projects_project_planning_issues_statuses_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::IssueStatus>, Error<ProjectsProjectPlanningIssuesStatusesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/statuses", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesStatusesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Configure issue statuses in a project. The list must contain at least one resolved and one unresolved status.
pub async fn projects_project_planning_issues_statuses_patch(configuration: &configuration::Configuration, project: &str, projects_project_planning_issues_statuses_patch_request: crate::models::ProjectsProjectPlanningIssuesStatusesPatchRequest) -> Result<(), Error<ProjectsProjectPlanningIssuesStatusesPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/statuses", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_issues_statuses_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesStatusesPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get issues in specified project for synchronization with third-party system. Issues with etag greater than specified value are returned. Read more in the [documentation](https://www.jetbrains.com/help/space/sync-api.html).
pub async fn projects_project_planning_issues_sync_batch_get(configuration: &configuration::Configuration, project: &str, batch_info: &str, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPlanningIssuesSyncBatchGet200Response, Error<ProjectsProjectPlanningIssuesSyncBatchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/issues/sync-batch", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("batchInfo", &batch_info.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningIssuesSyncBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search existing tags in a project
pub async fn projects_project_planning_tags_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectPlanningTagsGet200Response, Error<ProjectsProjectPlanningTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/tags", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new hierarchical tag in a project
pub async fn projects_project_planning_tags_post(configuration: &configuration::Configuration, project: &str, projects_project_planning_tags_post_request: crate::models::ProjectsProjectPlanningTagsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PlanningTag, Error<ProjectsProjectPlanningTagsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/planning/tags", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_tags_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectPlanningTagsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_additional_info_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::AdditionalRepositoryInfo, Error<ProjectsProjectRepositoriesRepositoryAdditionalInfoGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/additional-info", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryAdditionalInfoGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_changes_get(configuration: &configuration::Configuration, project: &str, repository: &str, commit: &str, limit: i32, dollar_fields: Option<&str>) -> Result<Vec<crate::models::GitFileChange>, Error<ProjectsProjectRepositoriesRepositoryChangesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/changes", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("commit", &commit.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("limit", &limit.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryChangesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_cherry_pick_commit_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_cherry_pick_commit_post_request: crate::models::ProjectsProjectRepositoriesRepositoryCherryPickCommitPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitCherryPickResult, Error<ProjectsProjectRepositoriesRepositoryCherryPickCommitPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/cherry-pick-commit", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_cherry_pick_commit_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryCherryPickCommitPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_commit_branches_get(configuration: &configuration::Configuration, project: &str, repository: &str, commit: &str, prefix: Option<&str>, limit: Option<i32>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BranchInfo>, Error<ProjectsProjectRepositoriesRepositoryCommitBranchesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/commit-branches", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("commit", &commit.to_string())]);
    if let Some(ref local_var_str) = prefix {
        local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryCommitBranchesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_commit_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_commit_post_request: crate::models::ProjectsProjectRepositoriesRepositoryCommitPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitCommitResult, Error<ProjectsProjectRepositoriesRepositoryCommitPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/commit", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_commit_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryCommitPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_commits_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectRepositoriesRepositoryCommitsGet200Response, Error<ProjectsProjectRepositoriesRepositoryCommitsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/commits", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryCommitsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_default_branch_get(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<String, Error<ProjectsProjectRepositoriesRepositoryDefaultBranchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/default-branch", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryDefaultBranchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_default_branch_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_delete_branch_post_request: crate::models::ProjectsProjectRepositoriesRepositoryDeleteBranchPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryDefaultBranchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/default-branch", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_delete_branch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryDefaultBranchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_delete(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_delete_branch_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_delete_branch_post_request: crate::models::ProjectsProjectRepositoriesRepositoryDeleteBranchPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryDeleteBranchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/delete-branch", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_delete_branch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryDeleteBranchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_description_post(configuration: &configuration::Configuration, project: &str, repository: &str, chats_channels_channel_description_patch_request: crate::models::ChatsChannelsChannelDescriptionPatchRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryDescriptionPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/description", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_channel_description_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryDescriptionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_files_get(configuration: &configuration::Configuration, project: &str, repository: &str, commit: &str, path: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::GitFile>, Error<ProjectsProjectRepositoriesRepositoryFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/files", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("commit", &commit.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("path", &path.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_gc_post(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryGcPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/gc", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryGcPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::PrRepositoryInfo, Error<ProjectsProjectRepositoriesRepositoryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_head_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_head_post_request: crate::models::ProjectsProjectRepositoriesRepositoryHeadPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryHeadPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/head", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_head_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryHeadPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_heads_get(configuration: &configuration::Configuration, project: &str, repository: &str, pattern: Option<Vec<String>>, is_regex: Option<bool>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectRepositoriesRepositoryHeadsGet200Response, Error<ProjectsProjectRepositoriesRepositoryHeadsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/heads", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = pattern {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("pattern".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("pattern", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = is_regex {
        local_var_req_builder = local_var_req_builder.query(&[("isRegex", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryHeadsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_inline_merge_diff_get(configuration: &configuration::Configuration, project: &str, repository: &str, entry_type: GitEntryType, base_blob_id: Option<&str>, source_blob_id: Option<&str>, target_blob_id: Option<&str>, ignore_whitespaces: Option<bool>, squash_simple_changes: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::InlineDiff, Error<ProjectsProjectRepositoriesRepositoryInlineMergeDiffGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/inline-merge-diff", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = base_blob_id {
        local_var_req_builder = local_var_req_builder.query(&[("baseBlobId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_blob_id {
        local_var_req_builder = local_var_req_builder.query(&[("sourceBlobId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = target_blob_id {
        local_var_req_builder = local_var_req_builder.query(&[("targetBlobId", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("entryType", &entry_type.to_string())]);
    if let Some(ref local_var_str) = ignore_whitespaces {
        local_var_req_builder = local_var_req_builder.query(&[("ignoreWhitespaces", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = squash_simple_changes {
        local_var_req_builder = local_var_req_builder.query(&[("squashSimpleChanges", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryInlineMergeDiffGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_merge_branch_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_merge_branch_post_request: crate::models::ProjectsProjectRepositoriesRepositoryMergeBranchPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitMergeBranchResult, Error<ProjectsProjectRepositoriesRepositoryMergeBranchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/merge-branch", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_merge_branch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryMergeBranchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_merge_preview_get(configuration: &configuration::Configuration, project: &str, repository: &str, source_branch: &str, target_branch: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectCodeReviewsReviewIdMergeFilesGet200Response, Error<ProjectsProjectRepositoriesRepositoryMergePreviewGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/merge-preview", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sourceBranch", &source_branch.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("targetBranch", &target_branch.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryMergePreviewGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Dry run merge source branch into target without modifying the repository. Please note that conflicting status is based on per-file analysis, so it may not be accurate on too diverged branches.
pub async fn projects_project_repositories_repository_merge_preview_status_get(configuration: &configuration::Configuration, project: &str, repository: &str, source_branch: &str, target_branch: &str, dollar_fields: Option<&str>) -> Result<crate::models::GitMergeBranchResult, Error<ProjectsProjectRepositoriesRepositoryMergePreviewStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/merge-preview-status", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sourceBranch", &source_branch.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("targetBranch", &target_branch.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryMergePreviewStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_migrate_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_migrate_post_request: crate::models::ProjectsProjectRepositoriesRepositoryMigratePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PrRepositoryInfo, Error<ProjectsProjectRepositoriesRepositoryMigratePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/migrate", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_migrate_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryMigratePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_post(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>, projects_project_repositories_repository_post_request: Option<crate::models::ProjectsProjectRepositoriesRepositoryPostRequest>) -> Result<crate::models::PrRepositoryInfo, Error<ProjectsProjectRepositoriesRepositoryPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_readonly_get(configuration: &configuration::Configuration, project: &str, repository: &str) -> Result<bool, Error<ProjectsProjectRepositoriesRepositoryReadonlyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/readonly", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryReadonlyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_readonly_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_readonly_post_request: crate::models::ProjectsProjectRepositoriesRepositoryReadonlyPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryReadonlyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/readonly", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_readonly_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryReadonlyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_rebase_branch_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_rebase_branch_post_request: crate::models::ProjectsProjectRepositoriesRepositoryRebaseBranchPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GitRebaseResult, Error<ProjectsProjectRepositoriesRepositoryRebaseBranchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/rebase-branch", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_rebase_branch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryRebaseBranchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_revisions_revision_external_checks_get(configuration: &configuration::Configuration, project: &str, repository: &str, revision: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::ExternalCheckDto>, Error<ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/revisions/{revision}/external-checks", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), revision=crate::apis::urlencode(revision));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_revisions_revision_external_checks_post(configuration: &configuration::Configuration, project: &str, repository: &str, revision: &str, projects_project_repositories_repository_revisions_revision_external_checks_post_request: crate::models::ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/revisions/{revision}/external-checks", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository), revision=crate::apis::urlencode(revision));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_revisions_revision_external_checks_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryRevisionsRevisionExternalChecksPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_settings_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::GitRepositorySettings, Error<ProjectsProjectRepositoriesRepositorySettingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/settings", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositorySettingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_settings_post(configuration: &configuration::Configuration, project: &str, repository: &str, projects_project_repositories_repository_settings_post_request: crate::models::ProjectsProjectRepositoriesRepositorySettingsPostRequest) -> Result<(), Error<ProjectsProjectRepositoriesRepositorySettingsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/settings", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_repository_settings_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositorySettingsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_repository_url_get(configuration: &configuration::Configuration, project: &str, repository: &str, dollar_fields: Option<&str>) -> Result<crate::models::RepositoryUrls, Error<ProjectsProjectRepositoriesRepositoryUrlGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/{repository}/url", local_var_configuration.base_path, project=crate::apis::urlencode(project), repository=crate::apis::urlencode(repository));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesRepositoryUrlGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_project_repositories_test_connection_post(configuration: &configuration::Configuration, project: &str, projects_project_repositories_test_connection_post_request: crate::models::ProjectsProjectRepositoriesTestConnectionPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TestConnectionResult, Error<ProjectsProjectRepositoriesTestConnectionPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/repositories/test-connection", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_repositories_test_connection_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectRepositoriesTestConnectionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a responsible person for a given project ID and responsibility ID
pub async fn projects_project_responsibilities_responsibility_id_assignees_profile_id_delete(configuration: &configuration::Configuration, project: &str, responsibility_id: &str, profile_id: &str, role: Option<&str>) -> Result<(), Error<ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/responsibilities/{responsibilityId}/assignees/{profileId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), responsibilityId=crate::apis::urlencode(responsibility_id), profileId=crate::apis::urlencode(profile_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Assign a responsible person for a given project ID and responsibility ID
pub async fn projects_project_responsibilities_responsibility_id_assignees_profile_id_post(configuration: &configuration::Configuration, project: &str, responsibility_id: &str, profile_id: &str, projects_project_responsibilities_responsibility_id_assignees_profile_id_post_request: Option<crate::models::ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdPostRequest>) -> Result<(), Error<ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/responsibilities/{responsibilityId}/assignees/{profileId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), responsibilityId=crate::apis::urlencode(responsibility_id), profileId=crate::apis::urlencode(profile_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_responsibilities_responsibility_id_assignees_profile_id_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectResponsibilitiesResponsibilityIdAssigneesProfileIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the responsibilities schema for a given project ID
pub async fn projects_project_responsibilities_scheme_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SubjectResponsibilitiesTable>, Error<ProjectsProjectResponsibilitiesSchemeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/responsibilities/scheme", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectResponsibilitiesSchemeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a responsibility subject for a given project ID
pub async fn projects_project_responsibilities_subjects_post(configuration: &configuration::Configuration, project: &str, projects_project_responsibilities_subjects_post_request: Option<crate::models::ProjectsProjectResponsibilitiesSubjectsPostRequest>) -> Result<String, Error<ProjectsProjectResponsibilitiesSubjectsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/responsibilities/subjects", local_var_configuration.base_path, project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_responsibilities_subjects_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsProjectResponsibilitiesSubjectsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing responsibility subject for a given project ID
pub async fn projects_project_responsibilities_subjects_subject_id_patch(configuration: &configuration::Configuration, project: &str, subject_id: &str, projects_project_responsibilities_subjects_post_request: Option<crate::models::ProjectsProjectResponsibilitiesSubjectsPostRequest>) -> Result<(), Error<ProjectsProjectResponsibilitiesSubjectsSubjectIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/{project}/responsibilities/subjects/{subjectId}", local_var_configuration.base_path, project=crate::apis::urlencode(project), subjectId=crate::apis::urlencode(subject_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_responsibilities_subjects_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsProjectResponsibilitiesSubjectsSubjectIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Find repositories by name substring.
pub async fn projects_repositories_find_get(configuration: &configuration::Configuration, term: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsRepositoriesFindGet200Response, Error<ProjectsRepositoriesFindGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/repositories/find", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("term", &term.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsRepositoriesFindGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a responsibility for a given subject ID
pub async fn projects_responsibilities_post(configuration: &configuration::Configuration, projects_responsibilities_post_request: crate::models::ProjectsResponsibilitiesPostRequest) -> Result<String, Error<ProjectsResponsibilitiesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/responsibilities", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_responsibilities_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsResponsibilitiesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing responsibility
pub async fn projects_responsibilities_responsibility_id_delete(configuration: &configuration::Configuration, responsibility_id: &str) -> Result<(), Error<ProjectsResponsibilitiesResponsibilityIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/responsibilities/{responsibilityId}", local_var_configuration.base_path, responsibilityId=crate::apis::urlencode(responsibility_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsResponsibilitiesResponsibilityIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit an existing responsibility
pub async fn projects_responsibilities_responsibility_id_patch(configuration: &configuration::Configuration, responsibility_id: &str, projects_responsibilities_responsibility_id_patch_request: crate::models::ProjectsResponsibilitiesResponsibilityIdPatchRequest) -> Result<(), Error<ProjectsResponsibilitiesResponsibilityIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/responsibilities/{responsibilityId}", local_var_configuration.base_path, responsibilityId=crate::apis::urlencode(responsibility_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_responsibilities_responsibility_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsResponsibilitiesResponsibilityIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing responsibility subject for a given project ID
pub async fn projects_responsibilities_subjects_subject_id_delete(configuration: &configuration::Configuration, subject_id: &str, project: Option<&str>) -> Result<(), Error<ProjectsResponsibilitiesSubjectsSubjectIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/responsibilities/subjects/{subjectId}", local_var_configuration.base_path, subjectId=crate::apis::urlencode(subject_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = project {
        local_var_req_builder = local_var_req_builder.query(&[("project", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsResponsibilitiesSubjectsSubjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_right_coderight_code_get(configuration: &configuration::Configuration, right_code: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, term: Option<&str>, path: Option<&str>, starred: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsRightCoderightCodeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/right-code:{rightCode}", local_var_configuration.base_path, rightCode=crate::apis::urlencode(right_code));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = term {
        local_var_req_builder = local_var_req_builder.query(&[("term", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = path {
        local_var_req_builder = local_var_req_builder.query(&[("path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starred {
        local_var_req_builder = local_var_req_builder.query(&[("starred", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsRightCoderightCodeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_right_unique_coderight_get(configuration: &configuration::Configuration, right: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, term: Option<&str>, path: Option<&str>, starred: Option<bool>, private: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsRightUniqueCoderightGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/right-unique-code:{right}", local_var_configuration.base_path, right=crate::apis::urlencode(right));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = term {
        local_var_req_builder = local_var_req_builder.query(&[("term", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = path {
        local_var_req_builder = local_var_req_builder.query(&[("path", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starred {
        local_var_req_builder = local_var_req_builder.query(&[("starred", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = private {
        local_var_req_builder = local_var_req_builder.query(&[("private", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsRightUniqueCoderightGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List project secrets in a parameter bundle
pub async fn projects_secrets_default_bundle_get(configuration: &configuration::Configuration, project: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsSecretsDefaultBundleGet200Response, Error<ProjectsSecretsDefaultBundleGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsSecretsDefaultBundleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new project secret. The secret value should be provided either as a base64-encoded value in [valueBase64], or as a reference to another secret in [secretReference].
pub async fn projects_secrets_default_bundle_post(configuration: &configuration::Configuration, projects_secrets_default_bundle_post_request: crate::models::ProjectsSecretsDefaultBundlePostRequest) -> Result<String, Error<ProjectsSecretsDefaultBundlePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_secrets_default_bundle_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsSecretsDefaultBundlePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing project secret
pub async fn projects_secrets_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<ProjectsSecretsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsSecretsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing project secret
pub async fn projects_secrets_id_patch(configuration: &configuration::Configuration, id: &str, projects_secrets_id_patch_request: Option<crate::models::ProjectsSecretsIdPatchRequest>) -> Result<(), Error<ProjectsSecretsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_secrets_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsSecretsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_secrets_in_default_bundle_get(configuration: &configuration::Configuration, project_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsSecretsDefaultBundleGet200Response, Error<ProjectsSecretsInDefaultBundleGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/in-default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("projectId", &project_id.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsSecretsInDefaultBundleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn projects_secrets_in_default_bundle_post(configuration: &configuration::Configuration, projects_secrets_in_default_bundle_post_request: crate::models::ProjectsSecretsInDefaultBundlePostRequest) -> Result<String, Error<ProjectsSecretsInDefaultBundlePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/secrets/in-default-bundle", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_secrets_in_default_bundle_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsSecretsInDefaultBundlePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all tags, mapped to the number of projects they are used in
pub async fn projects_tags_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PrTag>, Error<ProjectsTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Track a tag has been accessed
pub async fn projects_tags_track_access_post(configuration: &configuration::Configuration, projects_tags_track_access_post_request: crate::models::ProjectsTagsTrackAccessPostRequest) -> Result<(), Error<ProjectsTagsTrackAccessPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/tags/track-access", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_tags_track_access_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsTagsTrackAccessPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all projects for a team
pub async fn projects_teamteam_get(configuration: &configuration::Configuration, team: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsGet200Response, Error<ProjectsTeamteamGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/team:{team}", local_var_configuration.base_path, team=crate::apis::urlencode(team));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsTeamteamGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an existing Vault connections for project
pub async fn projects_vault_get(configuration: &configuration::Configuration, project: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::VaultConnectionRecord>, Error<ProjectsVaultGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/vault", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("project", &project.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsVaultGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing Vault connection
pub async fn projects_vault_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<ProjectsVaultIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/vault/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsVaultIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing Vault connection
pub async fn projects_vault_id_patch(configuration: &configuration::Configuration, id: &str, projects_vault_id_patch_request: crate::models::ProjectsVaultIdPatchRequest) -> Result<(), Error<ProjectsVaultIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/vault/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_vault_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ProjectsVaultIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new Vault connection for the project. Vault's AppRole Secret Id must be provided as base64 encoded string
pub async fn projects_vault_post(configuration: &configuration::Configuration, projects_vault_post_request: crate::models::ProjectsVaultPostRequest) -> Result<String, Error<ProjectsVaultPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/projects/vault", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_vault_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProjectsVaultPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all public holiday calendars
pub async fn public_holidays_calendars_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::PublicHolidaysCalendarsGet200Response, Error<PublicHolidaysCalendarsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/calendars", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysCalendarsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a public holiday calendar
pub async fn public_holidays_calendars_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<PublicHolidaysCalendarsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/calendars/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PublicHolidaysCalendarsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing public holiday calendar
pub async fn public_holidays_calendars_id_patch(configuration: &configuration::Configuration, id: &str, public_holidays_calendars_post_request: crate::models::PublicHolidaysCalendarsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PublicHolidayCalendarRecord, Error<PublicHolidaysCalendarsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/calendars/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&public_holidays_calendars_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysCalendarsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Import holidays in a public holiday calendar, using an attachment (.ics format) as the source
pub async fn public_holidays_calendars_import_post(configuration: &configuration::Configuration, public_holidays_calendars_import_post_request: crate::models::PublicHolidaysCalendarsImportPostRequest) -> Result<String, Error<PublicHolidaysCalendarsImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/calendars/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&public_holidays_calendars_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysCalendarsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a public holiday calendar for a location
pub async fn public_holidays_calendars_post(configuration: &configuration::Configuration, public_holidays_calendars_post_request: crate::models::PublicHolidaysCalendarsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PublicHolidayCalendarRecord, Error<PublicHolidaysCalendarsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/calendars", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&public_holidays_calendars_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysCalendarsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all holidays in a public holiday calendar. Parameters are applied as 'AND' filters.
pub async fn public_holidays_holidays_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, calendar: Option<&str>, location: Option<&str>, start_date: Option<&str>, end_date: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::PublicHolidaysHolidaysGet200Response, Error<PublicHolidaysHolidaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = calendar {
        local_var_req_builder = local_var_req_builder.query(&[("calendar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("startDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("endDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a holiday from a public holiday calendar
pub async fn public_holidays_holidays_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<PublicHolidaysHolidaysIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a holiday in a public holiday calendar. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn public_holidays_holidays_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, public_holidays_holidays_id_patch_request: Option<crate::models::PublicHolidaysHolidaysIdPatchRequest>) -> Result<crate::models::PublicHoliday, Error<PublicHolidaysHolidaysIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&public_holidays_holidays_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a holiday to a public holiday calendar and specify if it is a working day or not
pub async fn public_holidays_holidays_post(configuration: &configuration::Configuration, public_holidays_holidays_post_request: crate::models::PublicHolidaysHolidaysPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::PublicHoliday, Error<PublicHolidaysHolidaysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&public_holidays_holidays_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get holidays observed in the location(s) of the current profile during the selected period
pub async fn public_holidays_holidays_profile_holidays_get(configuration: &configuration::Configuration, start_date: &str, end_date: &str, profile: &str, working_days: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PublicHoliday>, Error<PublicHolidaysHolidaysProfileHolidaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays/profile-holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("startDate", &start_date.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("endDate", &end_date.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("profile", &profile.to_string())]);
    if let Some(ref local_var_str) = working_days {
        local_var_req_builder = local_var_req_builder.query(&[("workingDays", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysProfileHolidaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search related holidays in all public holiday calendars, during the selected period
pub async fn public_holidays_holidays_related_holidays_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, start_date: Option<&str>, end_date: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::PublicHolidaysHolidaysGet200Response, Error<PublicHolidaysHolidaysRelatedHolidaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/public-holidays/holidays/related-holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("startDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("endDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PublicHolidaysHolidaysRelatedHolidaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reactions_item_emoji_delete(configuration: &configuration::Configuration, item: &str, emoji: &str) -> Result<(), Error<ReactionsItemEmojiDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/reactions/{item}/{emoji}", local_var_configuration.base_path, item=crate::apis::urlencode(item), emoji=crate::apis::urlencode(emoji));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ReactionsItemEmojiDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reactions_item_emoji_get(configuration: &configuration::Configuration, item: &str, emoji: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::CPrincipal>, Error<ReactionsItemEmojiGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/reactions/{item}/{emoji}", local_var_configuration.base_path, item=crate::apis::urlencode(item), emoji=crate::apis::urlencode(emoji));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReactionsItemEmojiGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reactions_item_emoji_post(configuration: &configuration::Configuration, item: &str, emoji: &str) -> Result<(), Error<ReactionsItemEmojiPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/reactions/{item}/{emoji}", local_var_configuration.base_path, item=crate::apis::urlencode(item), emoji=crate::apis::urlencode(emoji));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ReactionsItemEmojiPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn reactions_item_get(configuration: &configuration::Configuration, item: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EmojiReaction>, Error<ReactionsItemGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/reactions/{item}", local_var_configuration.base_path, item=crate::apis::urlencode(item));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReactionsItemGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Parses [Space markdown syntax](https://www.jetbrains.com/help/space/markdown-syntax.html) into a tree presentation
pub async fn rich_text_parse_markdown_post(configuration: &configuration::Configuration, rich_text_parse_markdown_post_request: crate::models::RichTextParseMarkdownPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::RtDocument, Error<RichTextParseMarkdownPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/rich-text/parse-markdown", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rich_text_parse_markdown_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RichTextParseMarkdownPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search absences. Parameters are applied as 'AND' filters.
pub async fn team_directory_calendar_events_absence_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::AbsenceEvent>, Error<TeamDirectoryCalendarEventsAbsenceEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/absence-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsAbsenceEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search birthdays. Parameters are applied as 'AND' filters.
pub async fn team_directory_calendar_events_birthday_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BirthdayEvent>, Error<TeamDirectoryCalendarEventsBirthdayEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/birthday-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsBirthdayEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search birthdays in a specific time period for starred profiles.
pub async fn team_directory_calendar_events_birthday_events_starred_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::BirthdayEvent>, Error<TeamDirectoryCalendarEventsBirthdayEventsStarredGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/birthday-events/starred", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsBirthdayEventsStarredGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get calendar events attached to an article in a specific time period
pub async fn team_directory_calendar_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MeetingRecord>, Error<TeamDirectoryCalendarEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search holidays. Parameters are applied as 'AND' filters.
pub async fn team_directory_calendar_events_holidays_get(configuration: &configuration::Configuration, start_date: &str, end_date: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, working_days: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::HolidaysEvent>, Error<TeamDirectoryCalendarEventsHolidaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/holidays", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("startDate", &start_date.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("endDate", &end_date.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = working_days {
        local_var_req_builder = local_var_req_builder.query(&[("workingDays", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsHolidaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a calendar event attached to an article
pub async fn team_directory_calendar_events_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::MeetingRecord, Error<TeamDirectoryCalendarEventsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update RSVP / calendar event participation status for a calendar event attached to an article
pub async fn team_directory_calendar_events_meeting_participations_id_patch(configuration: &configuration::Configuration, id: &str, calendars_event_participations_id_patch_request: crate::models::CalendarsEventParticipationsIdPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::MeetingRecord, Error<TeamDirectoryCalendarEventsMeetingParticipationsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/meeting-participations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendars_event_participations_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsMeetingParticipationsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search membership events. Parameters are applied as 'AND' filters.
pub async fn team_directory_calendar_events_membership_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::MembershipEvent>, Error<TeamDirectoryCalendarEventsMembershipEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/membership-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsMembershipEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search non-working day events. Parameters are applied as 'AND' filters.
pub async fn team_directory_calendar_events_non_working_days_events_get(configuration: &configuration::Configuration, date_from: &str, date_to: &str, member: Option<&str>, team: Option<&str>, location: Option<&str>, role: Option<&str>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::NonWorkingDaysEvent>, Error<TeamDirectoryCalendarEventsNonWorkingDaysEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/calendar-events/non-working-days-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dateFrom", &date_from.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("dateTo", &date_to.to_string())]);
    if let Some(ref local_var_str) = member {
        local_var_req_builder = local_var_req_builder.query(&[("member", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team {
        local_var_req_builder = local_var_req_builder.query(&[("team", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location {
        local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryCalendarEventsNonWorkingDaysEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get organization-wide invitation links
pub async fn team_directory_invitation_links_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, with_deleted: Option<bool>, projects: Option<Vec<String>>, teams: Option<Vec<String>>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryInvitationLinksGet200Response, Error<TeamDirectoryInvitationLinksGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitation-links", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_deleted {
        local_var_req_builder = local_var_req_builder.query(&[("withDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projects {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("projects".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("projects", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = teams {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("teams", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationLinksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete currently active organization-wide invitation link
pub async fn team_directory_invitation_links_invitation_link_id_delete(configuration: &configuration::Configuration, invitation_link_id: &str) -> Result<(), Error<TeamDirectoryInvitationLinksInvitationLinkIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitation-links/{invitationLinkId}", local_var_configuration.base_path, invitationLinkId=crate::apis::urlencode(invitation_link_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationLinksInvitationLinkIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an organization-wide invitation link
pub async fn team_directory_invitation_links_invitation_link_id_patch(configuration: &configuration::Configuration, invitation_link_id: &str, team_directory_invitation_links_invitation_link_id_patch_request: Option<crate::models::TeamDirectoryInvitationLinksInvitationLinkIdPatchRequest>) -> Result<(), Error<TeamDirectoryInvitationLinksInvitationLinkIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitation-links/{invitationLinkId}", local_var_configuration.base_path, invitationLinkId=crate::apis::urlencode(invitation_link_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_invitation_links_invitation_link_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationLinksInvitationLinkIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create an organization-wide invitation link
pub async fn team_directory_invitation_links_post(configuration: &configuration::Configuration, team_directory_invitation_links_post_request: crate::models::TeamDirectoryInvitationLinksPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryInvitationLinksPost200Response, Error<TeamDirectoryInvitationLinksPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitation-links", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_invitation_links_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationLinksPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of invitations
pub async fn team_directory_invitations_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, with_deleted: Option<bool>, projects: Option<Vec<String>>, teams: Option<Vec<String>>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryInvitationsGet200Response, Error<TeamDirectoryInvitationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_deleted {
        local_var_req_builder = local_var_req_builder.query(&[("withDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projects {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("projects".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("projects", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = teams {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("teams", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an invitation. Deleted invitations can no longer be used to join the organization.
pub async fn team_directory_invitations_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<TeamDirectoryInvitationsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an invitation. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn team_directory_invitations_id_patch(configuration: &configuration::Configuration, id: &str, team_directory_invitations_id_patch_request: Option<crate::models::TeamDirectoryInvitationsIdPatchRequest>) -> Result<(), Error<TeamDirectoryInvitationsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_invitations_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create an invitation to join the current organization. Optionally, the team and/or role to join when accepting the invitation can be specified.
pub async fn team_directory_invitations_post(configuration: &configuration::Configuration, team_directory_invitations_post_request: crate::models::TeamDirectoryInvitationsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Invitation, Error<TeamDirectoryInvitationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/invitations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_invitations_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryInvitationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all languages
pub async fn team_directory_languages_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLanguage>, Error<TeamDirectoryLanguagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/languages", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLanguagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all equipment types
pub async fn team_directory_location_equipment_types_get(configuration: &configuration::Configuration, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocationEquipmentType>, Error<TeamDirectoryLocationEquipmentTypesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-equipment-types", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationEquipmentTypesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive/restore location equipment type. Setting delete to true will archive the equipment type, false will restore it.
pub async fn team_directory_location_equipment_types_namename_delete(configuration: &configuration::Configuration, name: &str, delete: bool) -> Result<(), Error<TeamDirectoryLocationEquipmentTypesNamenameDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-equipment-types/name:{name}", local_var_configuration.base_path, name=crate::apis::urlencode(name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("delete", &delete.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryLocationEquipmentTypesNamenameDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get members on a map for a location ID
pub async fn team_directory_location_map_member_points_get(configuration: &configuration::Configuration, location_id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, include_unmarked: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryLocationMapMemberPointsGet200Response, Error<TeamDirectoryLocationMapMemberPointsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-map-member-points", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("locationId", &location_id.to_string())]);
    if let Some(ref local_var_str) = include_unmarked {
        local_var_req_builder = local_var_req_builder.query(&[("includeUnmarked", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationMapMemberPointsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete member location from a map
pub async fn team_directory_location_map_member_points_location_point_id_delete(configuration: &configuration::Configuration, location_point_id: &str, delete: bool) -> Result<(), Error<TeamDirectoryLocationMapMemberPointsLocationPointIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-map-member-points/{locationPointId}", local_var_configuration.base_path, locationPointId=crate::apis::urlencode(location_point_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("delete", &delete.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryLocationMapMemberPointsLocationPointIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update member location on a map
pub async fn team_directory_location_map_member_points_location_point_id_patch(configuration: &configuration::Configuration, location_point_id: &str, dollar_fields: Option<&str>, team_directory_location_map_member_points_location_point_id_patch_request: Option<crate::models::TeamDirectoryLocationMapMemberPointsLocationPointIdPatchRequest>) -> Result<crate::models::TdLocationMapPoint, Error<TeamDirectoryLocationMapMemberPointsLocationPointIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-map-member-points/{locationPointId}", local_var_configuration.base_path, locationPointId=crate::apis::urlencode(location_point_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_location_map_member_points_location_point_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationMapMemberPointsLocationPointIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Mark member location on a map
pub async fn team_directory_location_map_member_points_post(configuration: &configuration::Configuration, team_directory_location_map_member_points_post_request: crate::models::TeamDirectoryLocationMapMemberPointsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdLocationMapPoint, Error<TeamDirectoryLocationMapMemberPointsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/location-map-member-points", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_location_map_member_points_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationMapMemberPointsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all locations. Parameters are applied as 'AND' filters.
pub async fn team_directory_locations_get(configuration: &configuration::Configuration, query: Option<&str>, r#type: Option<&str>, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocation>, Error<TeamDirectoryLocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive a location
pub async fn team_directory_locations_id_delete(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocation>, Error<TeamDirectoryLocationsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a location by ID
pub async fn team_directory_locations_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdLocation, Error<TeamDirectoryLocationsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get map for a location ID
pub async fn team_directory_locations_id_map_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdLocationMap, Error<TeamDirectoryLocationsIdMapGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}/map", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdMapGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the map for a location
pub async fn team_directory_locations_id_map_patch(configuration: &configuration::Configuration, id: &str, team_directory_locations_id_map_patch_request: crate::models::TeamDirectoryLocationsIdMapPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdLocationMap, Error<TeamDirectoryLocationsIdMapPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}/map", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_locations_id_map_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdMapPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a location. Optional parameters will be ignored when null and updated otherwise.
pub async fn team_directory_locations_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, team_directory_locations_id_patch_request: Option<crate::models::TeamDirectoryLocationsIdPatchRequest>) -> Result<crate::models::TdLocation, Error<TeamDirectoryLocationsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_locations_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore an archived location
pub async fn team_directory_locations_id_restore_post(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdLocation, Error<TeamDirectoryLocationsIdRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/{id}/restore", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsIdRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a location
pub async fn team_directory_locations_post(configuration: &configuration::Configuration, team_directory_locations_post_request: crate::models::TeamDirectoryLocationsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdLocation, Error<TeamDirectoryLocationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_locations_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore one or more archived locations
pub async fn team_directory_locations_restore_post(configuration: &configuration::Configuration, team_directory_locations_restore_post_request: crate::models::TeamDirectoryLocationsRestorePostRequest, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocation>, Error<TeamDirectoryLocationsRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations/restore", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_locations_restore_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all locations with their time zone
pub async fn team_directory_locations_with_timezone_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocationWithTimeZone>, Error<TeamDirectoryLocationsWithTimezoneGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/locations-with-timezone", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryLocationsWithTimezoneGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search member locations. Parameters are applied as 'AND' filters.
pub async fn team_directory_member_locations_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, profiles: Option<Vec<String>>, locations: Option<Vec<String>>, since: Option<&str>, till: Option<&str>, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryMemberLocationsGet200Response, Error<TeamDirectoryMemberLocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/member-locations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profiles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("profiles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = locations {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("locations".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("locations", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMemberLocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive/unarchive a member location. Setting delete to true will archive the member location, false will restore it.
pub async fn team_directory_member_locations_member_location_id_delete(configuration: &configuration::Configuration, member_location_id: &str, delete: Option<bool>) -> Result<(), Error<TeamDirectoryMemberLocationsMemberLocationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/member-locations/{memberLocationId}", local_var_configuration.base_path, memberLocationId=crate::apis::urlencode(member_location_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryMemberLocationsMemberLocationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a member location by its ID
pub async fn team_directory_member_locations_member_location_id_get(configuration: &configuration::Configuration, member_location_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberLocation, Error<TeamDirectoryMemberLocationsMemberLocationIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/member-locations/{memberLocationId}", local_var_configuration.base_path, memberLocationId=crate::apis::urlencode(member_location_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMemberLocationsMemberLocationIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update member location. Optional parameters will be ignored when null and updated otherwise.
pub async fn team_directory_member_locations_member_location_id_patch(configuration: &configuration::Configuration, member_location_id: &str, dollar_fields: Option<&str>, team_directory_member_locations_member_location_id_patch_request: Option<crate::models::TeamDirectoryMemberLocationsMemberLocationIdPatchRequest>) -> Result<crate::models::TdMemberLocation, Error<TeamDirectoryMemberLocationsMemberLocationIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/member-locations/{memberLocationId}", local_var_configuration.base_path, memberLocationId=crate::apis::urlencode(member_location_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_member_locations_member_location_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMemberLocationsMemberLocationIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a member location, optionally from/until a given date
pub async fn team_directory_member_locations_post(configuration: &configuration::Configuration, team_directory_member_locations_post_request: crate::models::TeamDirectoryMemberLocationsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberLocation, Error<TeamDirectoryMemberLocationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/member-locations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_member_locations_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMemberLocationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search membership events. Parameters are applied as 'AND' filters.
pub async fn team_directory_membership_events_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, team_id: Option<&str>, location_id: Option<&str>, role_id: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryMembershipEventsGet200Response, Error<TeamDirectoryMembershipEventsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/membership-events", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_id {
        local_var_req_builder = local_var_req_builder.query(&[("locationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role_id {
        local_var_req_builder = local_var_req_builder.query(&[("roleId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipEventsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search team memberships. Parameters are applied as 'AND' filters.
pub async fn team_directory_memberships_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, identifiers: Option<Vec<String>>, profiles: Option<Vec<String>>, teams: Option<Vec<String>>, direct_teams: Option<bool>, roles: Option<Vec<String>>, direct_roles: Option<bool>, since: Option<String>, till: Option<String>, requires_approval: Option<bool>, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryMembershipsGet200Response, Error<TeamDirectoryMembershipsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = identifiers {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("identifiers".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("identifiers", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = profiles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("profiles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = teams {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("teams".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("teams", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = direct_teams {
        local_var_req_builder = local_var_req_builder.query(&[("directTeams", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = roles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("roles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("roles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = direct_roles {
        local_var_req_builder = local_var_req_builder.query(&[("directRoles", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = requires_approval {
        local_var_req_builder = local_var_req_builder.query(&[("requiresApproval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Query profiles that can be a manager
pub async fn team_directory_memberships_manager_candidates_get(configuration: &configuration::Configuration, term: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, team_id: Option<&str>, excluded_member_id: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<TeamDirectoryMembershipsManagerCandidatesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/manager-candidates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("term", &term.to_string())]);
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = excluded_member_id {
        local_var_req_builder = local_var_req_builder.query(&[("excludedMemberId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsManagerCandidatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive/unarchive a team membership. Setting delete to true will archive the membership, false will restore it.
pub async fn team_directory_memberships_membership_id_delete(configuration: &configuration::Configuration, membership_id: &str, delete: Option<bool>) -> Result<(), Error<TeamDirectoryMembershipsMembershipIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/{membershipId}", local_var_configuration.base_path, membershipId=crate::apis::urlencode(membership_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsMembershipIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a single membership by its identifier
pub async fn team_directory_memberships_membership_id_get(configuration: &configuration::Configuration, membership_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMembership, Error<TeamDirectoryMembershipsMembershipIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/{membershipId}", local_var_configuration.base_path, membershipId=crate::apis::urlencode(membership_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsMembershipIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a team membership. Optional parameters will be ignored when null and updated otherwise.
pub async fn team_directory_memberships_membership_id_patch(configuration: &configuration::Configuration, membership_id: &str, dollar_fields: Option<&str>, team_directory_memberships_membership_id_patch_request: Option<crate::models::TeamDirectoryMembershipsMembershipIdPatchRequest>) -> Result<crate::models::TdMembership, Error<TeamDirectoryMembershipsMembershipIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/{membershipId}", local_var_configuration.base_path, membershipId=crate::apis::urlencode(membership_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_memberships_membership_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsMembershipIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request a team membership to end at a given date/time. Will need approval.
pub async fn team_directory_memberships_membership_id_request_revoke_patch(configuration: &configuration::Configuration, membership_id: &str, team_directory_memberships_membership_id_request_revoke_patch_request: crate::models::TeamDirectoryMembershipsMembershipIdRequestRevokePatchRequest) -> Result<(), Error<TeamDirectoryMembershipsMembershipIdRequestRevokePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/{membershipId}/request-revoke", local_var_configuration.base_path, membershipId=crate::apis::urlencode(membership_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_memberships_membership_id_request_revoke_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsMembershipIdRequestRevokePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revoke a team membership to end at a given date/time
pub async fn team_directory_memberships_membership_id_revoke_delete(configuration: &configuration::Configuration, membership_id: &str, till: Option<String>) -> Result<(), Error<TeamDirectoryMembershipsMembershipIdRevokeDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/{membershipId}/revoke", local_var_configuration.base_path, membershipId=crate::apis::urlencode(membership_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsMembershipIdRevokeDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a team membership
pub async fn team_directory_memberships_post(configuration: &configuration::Configuration, team_directory_memberships_post_request: crate::models::TeamDirectoryMembershipsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdMembership, Error<TeamDirectoryMembershipsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_memberships_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all membership requests. Parameters are applied as 'AND' filters.
pub async fn team_directory_memberships_requests_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, team_id: Option<&str>, direct: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryMembershipsRequestsGet200Response, Error<TeamDirectoryMembershipsRequestsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/requests", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = direct {
        local_var_req_builder = local_var_req_builder.query(&[("direct", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsRequestsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a team membership request
pub async fn team_directory_memberships_requests_membership_request_id_delete(configuration: &configuration::Configuration, membership_request_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMembership, Error<TeamDirectoryMembershipsRequestsMembershipRequestIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/requests/{membershipRequestId}", local_var_configuration.base_path, membershipRequestId=crate::apis::urlencode(membership_request_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsRequestsMembershipRequestIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Approve/reject a team membership request. Setting approved to true will approve the membership request, false will reject it.
pub async fn team_directory_memberships_requests_membership_request_id_patch(configuration: &configuration::Configuration, membership_request_id: &str, team_directory_memberships_requests_membership_request_id_patch_request: crate::models::TeamDirectoryMembershipsRequestsMembershipRequestIdPatchRequest) -> Result<(), Error<TeamDirectoryMembershipsRequestsMembershipRequestIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/requests/{membershipRequestId}", local_var_configuration.base_path, membershipRequestId=crate::apis::urlencode(membership_request_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_memberships_requests_membership_request_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsRequestsMembershipRequestIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get memberships for synchronization with third-party system. Memberships with etag greater than specified value are returned. Read more in the [documentation](https://www.jetbrains.com/help/space/sync-api.html).
pub async fn team_directory_memberships_sync_batch_get(configuration: &configuration::Configuration, batch_info: &str, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryMembershipsSyncBatchGet200Response, Error<TeamDirectoryMembershipsSyncBatchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/memberships/sync-batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("batchInfo", &batch_info.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryMembershipsSyncBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the current authentication sessions for a given profile ID
pub async fn team_directory_profiles_authentication_sessions_owner_get(configuration: &configuration::Configuration, owner: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EsAuthenticationSession>, Error<TeamDirectoryProfilesAuthenticationSessionsOwnerGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/authentication-sessions/{owner}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesAuthenticationSessionsOwnerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Terminate an existing authentication session. Doing so will close the session and log out.
pub async fn team_directory_profiles_authentication_sessions_owner_session_id_delete(configuration: &configuration::Configuration, owner: &str, session_id: &str) -> Result<(), Error<TeamDirectoryProfilesAuthenticationSessionsOwnerSessionIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/authentication-sessions/{owner}/{sessionId}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), sessionId=crate::apis::urlencode(session_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesAuthenticationSessionsOwnerSessionIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_dashboards_dashboard_get(configuration: &configuration::Configuration, dashboard: &str, dollar_fields: Option<&str>) -> Result<crate::models::DashboardPreferencesRecord, Error<TeamDirectoryProfilesDashboardsDashboardGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/dashboards/{dashboard}", local_var_configuration.base_path, dashboard=crate::apis::urlencode(dashboard));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesDashboardsDashboardGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_dashboards_dashboard_patch(configuration: &configuration::Configuration, dashboard: &str, team_directory_profiles_dashboards_dashboard_patch_request: crate::models::TeamDirectoryProfilesDashboardsDashboardPatchRequest) -> Result<(), Error<TeamDirectoryProfilesDashboardsDashboardPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/dashboards/{dashboard}", local_var_configuration.base_path, dashboard=crate::apis::urlencode(dashboard));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_dashboards_dashboard_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesDashboardsDashboardPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get profile information by email address
pub async fn team_directory_profiles_emailemail_get(configuration: &configuration::Configuration, email: &str, verified: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesEmailemailGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/email:{email}", local_var_configuration.base_path, email=crate::apis::urlencode(email));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = verified {
        local_var_req_builder = local_var_req_builder.query(&[("verified", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesEmailemailGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// IDs of favorite deployment targets
pub async fn team_directory_profiles_favorites_deployment_targets_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<TeamDirectoryProfilesFavoritesDeploymentTargetsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/deployment-targets", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesDeploymentTargetsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// IDs of favorite documents
pub async fn team_directory_profiles_favorites_documents_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<TeamDirectoryProfilesFavoritesDocumentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/documents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesDocumentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove an entity with the given `id` and of the given `kind` from favorites. For profiles this operation is called “unfollow” in the user interface.
pub async fn team_directory_profiles_favorites_id_delete(configuration: &configuration::Configuration, id: &str, kind: StarredItemKind) -> Result<(), Error<TeamDirectoryProfilesFavoritesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("kind", &kind.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// IDs of favorite jobs
pub async fn team_directory_profiles_favorites_jobs_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<TeamDirectoryProfilesFavoritesJobsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/jobs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesJobsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Favorite locations
pub async fn team_directory_profiles_favorites_locations_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdLocation>, Error<TeamDirectoryProfilesFavoritesLocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/locations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesLocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add an entity with the given `id` and of the given `kind` to favorites. For profiles this operation is called “follow” in the user interface.
pub async fn team_directory_profiles_favorites_post(configuration: &configuration::Configuration, team_directory_profiles_favorites_post_request: crate::models::TeamDirectoryProfilesFavoritesPostRequest) -> Result<(), Error<TeamDirectoryProfilesFavoritesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_favorites_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Followed profiles
pub async fn team_directory_profiles_favorites_profiles_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<TeamDirectoryProfilesFavoritesProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Favorite projects
pub async fn team_directory_profiles_favorites_projects_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PrProject>, Error<TeamDirectoryProfilesFavoritesProjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/projects", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesProjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// IDs of favorite code repositories
pub async fn team_directory_profiles_favorites_repositories_get(configuration: &configuration::Configuration, ) -> Result<Vec<String>, Error<TeamDirectoryProfilesFavoritesRepositoriesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesRepositoriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Favorite teams
pub async fn team_directory_profiles_favorites_teams_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdTeam>, Error<TeamDirectoryProfilesFavoritesTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/favorites/teams", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesFavoritesTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all profiles. Parameters are applied as 'AND' filters.
pub async fn team_directory_profiles_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, report_past_members: Option<bool>, report_future_members: Option<bool>, report_current_members: Option<bool>, team_id: Option<&str>, location_id: Option<&str>, role_id: Option<&str>, me_on_top: Option<bool>, order: Option<ProfileOrder>, org_relation: Option<ProfileOrgRelation>, profiles: Option<Vec<String>>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<TeamDirectoryProfilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = report_past_members {
        local_var_req_builder = local_var_req_builder.query(&[("reportPastMembers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = report_future_members {
        local_var_req_builder = local_var_req_builder.query(&[("reportFutureMembers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = report_current_members {
        local_var_req_builder = local_var_req_builder.query(&[("reportCurrentMembers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_id {
        local_var_req_builder = local_var_req_builder.query(&[("locationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role_id {
        local_var_req_builder = local_var_req_builder.query(&[("roleId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = me_on_top {
        local_var_req_builder = local_var_req_builder.query(&[("meOnTop", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = org_relation {
        local_var_req_builder = local_var_req_builder.query(&[("orgRelation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profiles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("profiles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a previously approved application
pub async fn team_directory_profiles_oauth_consents_owner_applications_application_delete(configuration: &configuration::Configuration, owner: &str, application: &str) -> Result<(), Error<TeamDirectoryProfilesOauthConsentsOwnerApplicationsApplicationDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/oauth-consents/{owner}/applications/{application}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), application=crate::apis::urlencode(application));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesOauthConsentsOwnerApplicationsApplicationDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a previously approved scope
pub async fn team_directory_profiles_oauth_consents_owner_approved_scopes_id_delete(configuration: &configuration::Configuration, owner: &str, id: &str) -> Result<(), Error<TeamDirectoryProfilesOauthConsentsOwnerApprovedScopesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/oauth-consents/{owner}/approved-scopes/{id}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesOauthConsentsOwnerApprovedScopesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all OAuth consents for a given profile ID
pub async fn team_directory_profiles_oauth_consents_owner_get(configuration: &configuration::Configuration, owner: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::EsOAuthConsent>, Error<TeamDirectoryProfilesOauthConsentsOwnerGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/oauth-consents/{owner}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesOauthConsentsOwnerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a previously approved internal application
pub async fn team_directory_profiles_oauth_consents_owner_internal_applications_client_id_delete(configuration: &configuration::Configuration, owner: &str, client_id: &str) -> Result<(), Error<TeamDirectoryProfilesOauthConsentsOwnerInternalApplicationsClientIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/oauth-consents/{owner}/internal-applications/{clientId}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), clientId=crate::apis::urlencode(client_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesOauthConsentsOwnerInternalApplicationsClientIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a refresh token. This will require the client to re-authenticate.
pub async fn team_directory_profiles_oauth_consents_owner_refresh_tokens_id_delete(configuration: &configuration::Configuration, owner: &str, id: &str) -> Result<(), Error<TeamDirectoryProfilesOauthConsentsOwnerRefreshTokensIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/oauth-consents/{owner}/refresh-tokens/{id}", local_var_configuration.base_path, owner=crate::apis::urlencode(owner), id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesOauthConsentsOwnerRefreshTokensIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a profile
pub async fn team_directory_profiles_post(configuration: &configuration::Configuration, team_directory_profiles_post_request: crate::models::TeamDirectoryProfilesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get two-factor authentication requirements for a given profile ID. The response indicates whether two-factor authentication is required by participation in some permission roles.
pub async fn team_directory_profiles_profile2_fa_requirements_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::Profile2FaRequirement>, Error<TeamDirectoryProfilesProfile2FaRequirementsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/requirements", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaRequirementsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get two-factor authentication status for a given profile ID. The response indicates whether two-factor authentication is active, not active, or not set up yet.
pub async fn team_directory_profiles_profile2_fa_status_get(configuration: &configuration::Configuration, profile: &str) -> Result<crate::models::TwoFactorAuthenticationStatus, Error<TeamDirectoryProfilesProfile2FaStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/status", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Confirm two-factor authentication for a given profile ID using a TOTP (Time-based One-time Password) code from an app.
pub async fn team_directory_profiles_profile2_fa_totp_confirm_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile2_fa_totp_confirm_post_request: crate::models::TeamDirectoryProfilesProfile2FaTotpConfirmPostRequest) -> Result<(), Error<TeamDirectoryProfilesProfile2FaTotpConfirmPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/totp/confirm", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile2_fa_totp_confirm_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaTotpConfirmPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove two-factor authentication settings for a given profile ID. Previously generated TOTP (Time-based One-time Password) are rendered invalid.
pub async fn team_directory_profiles_profile2_fa_totp_delete(configuration: &configuration::Configuration, profile: &str, code: Option<i32>) -> Result<(), Error<TeamDirectoryProfilesProfile2FaTotpDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/totp", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = code {
        local_var_req_builder = local_var_req_builder.query(&[("code", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaTotpDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Enable/disable two-factor authentication settings for a given profile ID
pub async fn team_directory_profiles_profile2_fa_totp_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile2_fa_totp_patch_request: crate::models::TeamDirectoryProfilesProfile2FaTotpPatchRequest) -> Result<(), Error<TeamDirectoryProfilesProfile2FaTotpPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/totp", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile2_fa_totp_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaTotpPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set up two-factor authentication using TOTP (Time-based One-time Password) for a given profile ID. The response will return a QR code (base64 encoded) that can be scanned with an app to setup two-factor authentication. The code that the app generates has to be confirmed in Space to enable TOTP.
pub async fn team_directory_profiles_profile2_fa_totp_post(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::TwoFactorAuthenticationSecret, Error<TeamDirectoryProfilesProfile2FaTotpPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/2-fa/totp", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfile2FaTotpPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_application_passwords_get(configuration: &configuration::Configuration, profile: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesProfileApplicationPasswordsGet200Response, Error<TeamDirectoryProfilesProfileApplicationPasswordsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/application-passwords", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileApplicationPasswordsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_application_passwords_password_id_delete(configuration: &configuration::Configuration, profile: &str, password_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/application-passwords/{passwordId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), passwordId=crate::apis::urlencode(password_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_application_passwords_password_id_patch(configuration: &configuration::Configuration, profile: &str, password_id: &str, team_directory_profiles_profile_application_passwords_password_id_patch_request: Option<crate::models::TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/application-passwords/{passwordId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), passwordId=crate::apis::urlencode(password_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_application_passwords_password_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileApplicationPasswordsPasswordIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_application_passwords_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_application_passwords_post_request: crate::models::TeamDirectoryProfilesProfileApplicationPasswordsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesProfileApplicationPasswordsPost200Response, Error<TeamDirectoryProfilesProfileApplicationPasswordsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/application-passwords", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_application_passwords_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileApplicationPasswordsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing checklist associated with the profile
pub async fn team_directory_profiles_profile_checklists_checklist_id_delete(configuration: &configuration::Configuration, profile: &str, checklist_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfileChecklistsChecklistIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/{checklistId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsChecklistIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the content of a checklist associated with the profile
pub async fn team_directory_profiles_profile_checklists_checklist_id_full_checklist_tree_get(configuration: &configuration::Configuration, profile: &str, checklist_id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PlanItemChildren>, Error<TeamDirectoryProfilesProfileChecklistsChecklistIdFullChecklistTreeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/{checklistId}/full-checklist-tree", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsChecklistIdFullChecklistTreeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Tab indented lines are converted into checkable items following the same rules as in Import Checklist. The result is placed inside of the specified personal checklist.
pub async fn team_directory_profiles_profile_checklists_checklist_id_import_post(configuration: &configuration::Configuration, profile: &str, checklist_id: &str, projects_project_planning_checklists_checklist_id_import_post_request: crate::models::ProjectsProjectPlanningChecklistsChecklistIdImportPostRequest) -> Result<(), Error<TeamDirectoryProfilesProfileChecklistsChecklistIdImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/{checklistId}/import", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_checklists_checklist_id_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsChecklistIdImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing checklist associated with the profile
pub async fn team_directory_profiles_profile_checklists_checklist_id_patch(configuration: &configuration::Configuration, profile: &str, checklist_id: &str, team_directory_profiles_profile_checklists_checklist_id_patch_request: Option<crate::models::TeamDirectoryProfilesProfileChecklistsChecklistIdPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfileChecklistsChecklistIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/{checklistId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), checklistId=crate::apis::urlencode(checklist_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_checklists_checklist_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsChecklistIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all existing checklists associated with the profile
pub async fn team_directory_profiles_profile_checklists_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::Checklist>, Error<TeamDirectoryProfilesProfileChecklistsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new checklist associated with the profile using tab indented lines as checkable items. The items with the same indent level will be placed one under the other. An issue URL will be converted into the corresponding issue.
pub async fn team_directory_profiles_profile_checklists_import_post(configuration: &configuration::Configuration, profile: &str, projects_project_planning_checklists_import_post_request: crate::models::ProjectsProjectPlanningChecklistsImportPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Checklist, Error<TeamDirectoryProfilesProfileChecklistsImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/import", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_planning_checklists_import_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new checklist associated with the profile
pub async fn team_directory_profiles_profile_checklists_post(configuration: &configuration::Configuration, profile: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Checklist, Error<TeamDirectoryProfilesProfileChecklistsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all starred checklists associated with the profile
pub async fn team_directory_profiles_profile_checklists_starred_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::Checklist>, Error<TeamDirectoryProfilesProfileChecklistsStarredGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/checklists/starred", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileChecklistsStarredGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Convert to guest profile
pub async fn team_directory_profiles_profile_convert_to_guest_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_convert_to_guest_patch_request: crate::models::TeamDirectoryProfilesProfileConvertToGuestPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DryRunResult, Error<TeamDirectoryProfilesProfileConvertToGuestPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/convert-to-guest", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_convert_to_guest_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileConvertToGuestPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Convert to organization member
pub async fn team_directory_profiles_profile_convert_to_member_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_convert_to_member_patch_request: crate::models::TeamDirectoryProfilesProfileConvertToMemberPatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DryRunResult, Error<TeamDirectoryProfilesProfileConvertToMemberPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/convert-to-member", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_convert_to_member_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileConvertToMemberPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deactivate a user profile
pub async fn team_directory_profiles_profile_deactivate_delete(configuration: &configuration::Configuration, profile: &str, at: String, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileDeactivateDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/deactivate", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("at", &at.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDeactivateDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a profile
pub async fn team_directory_profiles_profile_delete(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_access_get(configuration: &configuration::Configuration, profile: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::DocumentAccess, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}/access", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_access_patch(configuration: &configuration::Configuration, profile: &str, document_id: &str, projects_project_documents_document_id_access_patch_request: crate::models::ProjectsProjectDocumentsDocumentIdAccessPatchRequest) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsDocumentIdAccessPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}/access", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_access_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdAccessPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_copy_post(configuration: &configuration::Configuration, profile: &str, document_id: &str, projects_project_documents_document_id_copy_post_request: crate::models::ProjectsProjectDocumentsDocumentIdCopyPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdCopyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}/copy", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_copy_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdCopyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_delete(configuration: &configuration::Configuration, profile: &str, document_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsDocumentIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_get(configuration: &configuration::Configuration, profile: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_move_patch(configuration: &configuration::Configuration, profile: &str, document_id: &str, projects_project_documents_document_id_move_patch_request: crate::models::ProjectsProjectDocumentsDocumentIdMovePatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdMovePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}/move", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_move_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdMovePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_patch(configuration: &configuration::Configuration, profile: &str, document_id: &str, dollar_fields: Option<&str>, projects_project_documents_document_id_patch_request: Option<crate::models::ProjectsProjectDocumentsDocumentIdPatchRequest>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_document_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_document_id_unarchive_patch(configuration: &configuration::Configuration, profile: &str, document_id: &str, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsDocumentIdUnarchivePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/{documentId}/unarchive", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsDocumentIdUnarchivePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_access_get(configuration: &configuration::Configuration, profile: &str, folder: &str, dollar_fields: Option<&str>) -> Result<crate::models::FolderAccess, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/access", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_access_patch(configuration: &configuration::Configuration, profile: &str, folder: &str, projects_project_documents_folders_folder_access_patch_request: crate::models::ProjectsProjectDocumentsFoldersFolderAccessPatchRequest) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/access", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_folder_access_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderAccessPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_delete(configuration: &configuration::Configuration, profile: &str, folder: &str) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_documents_get(configuration: &configuration::Configuration, profile: &str, folder: &str, with_archived: Option<bool>, sort_by: Option<&str>, order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderDocumentsGet200Response, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderDocumentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/documents", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderDocumentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_get(configuration: &configuration::Configuration, profile: &str, folder: &str, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_introduction_delete(configuration: &configuration::Configuration, profile: &str, folder: &str) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/introduction", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_introduction_document_id_patch(configuration: &configuration::Configuration, profile: &str, folder: &str, document_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDocumentIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/introduction/{documentId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder), documentId=crate::apis::urlencode(document_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderIntroductionDocumentIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_move_patch(configuration: &configuration::Configuration, profile: &str, folder: &str, projects_project_documents_folders_folder_move_patch_request: crate::models::ProjectsProjectDocumentsFoldersFolderMovePatchRequest, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderMovePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/move", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_folder_move_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderMovePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_patch(configuration: &configuration::Configuration, profile: &str, folder: &str, chats_channels_is_name_free_post_request: crate::models::ChatsChannelsIsNameFreePostRequest) -> Result<(), Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&chats_channels_is_name_free_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Executes search for personal documents and folders in specified folder
pub async fn team_directory_profiles_profile_documents_folders_folder_search_get(configuration: &configuration::Configuration, profile: &str, folder: &str, query: &str, include_body: Option<bool>, folders_only: Option<bool>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderSearchGet200Response, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderSearchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/search", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_str) = include_body {
        local_var_req_builder = local_var_req_builder.query(&[("includeBody", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = folders_only {
        local_var_req_builder = local_var_req_builder.query(&[("foldersOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_folder_subfolders_get(configuration: &configuration::Configuration, profile: &str, folder: &str, with_archived: Option<bool>, sort_by: Option<&str>, order: Option<ColumnSortOrder>, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::ProjectsProjectDocumentsFoldersFolderSubfoldersGet200Response, Error<TeamDirectoryProfilesProfileDocumentsFoldersFolderSubfoldersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders/{folder}/subfolders", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), folder=crate::apis::urlencode(folder));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_by {
        local_var_req_builder = local_var_req_builder.query(&[("sortBy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order {
        local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersFolderSubfoldersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_folders_post(configuration: &configuration::Configuration, profile: &str, projects_project_documents_folders_post_request: crate::models::ProjectsProjectDocumentsFoldersPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::DocumentFolder, Error<TeamDirectoryProfilesProfileDocumentsFoldersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents/folders", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_folders_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsFoldersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_documents_post(configuration: &configuration::Configuration, profile: &str, projects_project_documents_post_request: crate::models::ProjectsProjectDocumentsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::Document, Error<TeamDirectoryProfilesProfileDocumentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/documents", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&projects_project_documents_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileDocumentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get profile information
pub async fn team_directory_profiles_profile_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_gpg_keys_fingerprint_delete(configuration: &configuration::Configuration, profile: &str, fingerprint: &str) -> Result<(), Error<TeamDirectoryProfilesProfileGpgKeysFingerprintDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/gpg-keys/{fingerprint}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileGpgKeysFingerprintDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_gpg_keys_fingerprint_patch(configuration: &configuration::Configuration, profile: &str, fingerprint: &str, applications_application_gpg_keys_fingerprint_patch_request: Option<crate::models::ApplicationsApplicationGpgKeysFingerprintPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfileGpgKeysFingerprintPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/gpg-keys/{fingerprint}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_gpg_keys_fingerprint_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileGpgKeysFingerprintPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List GPG public keys associated with a profile
pub async fn team_directory_profiles_profile_gpg_keys_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::GpgKeyData>, Error<TeamDirectoryProfilesProfileGpgKeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/gpg-keys", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileGpgKeysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_gpg_keys_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_gpg_keys_post_request: crate::models::TeamDirectoryProfilesProfileGpgKeysPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::GpgKeyData, Error<TeamDirectoryProfilesProfileGpgKeysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/gpg-keys", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_gpg_keys_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileGpgKeysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check if a user profile is a member of one or more teams
pub async fn team_directory_profiles_profile_is_team_member_get(configuration: &configuration::Configuration, profile: &str, team_ids: Vec<String>) -> Result<bool, Error<TeamDirectoryProfilesProfileIsTeamMemberGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/is-team-member", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&team_ids.into_iter().map(|p| ("teamIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("teamIds", &team_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileIsTeamMemberGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get team leads for a given profile ID
pub async fn team_directory_profiles_profile_leads_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdMemberProfile>, Error<TeamDirectoryProfilesProfileLeadsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/leads", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileLeadsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_nav_bar_menu_items_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::NavBarMenuItem>, Error<TeamDirectoryProfilesProfileNavBarMenuItemsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/nav-bar-menu-items", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNavBarMenuItemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Toggle visibility for a given navigation bar item
pub async fn team_directory_profiles_profile_nav_bar_menu_items_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_nav_bar_menu_items_patch_request: crate::models::TeamDirectoryProfilesProfileNavBarMenuItemsPatchRequest) -> Result<(), Error<TeamDirectoryProfilesProfileNavBarMenuItemsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/nav-bar-menu-items", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_nav_bar_menu_items_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNavBarMenuItemsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a project to the navigation bar
pub async fn team_directory_profiles_profile_nav_bar_projects_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::PrProject>, Error<TeamDirectoryProfilesProfileNavBarProjectsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/nav-bar-projects", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNavBarProjectsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a project to the navigation bar
pub async fn team_directory_profiles_profile_nav_bar_projects_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_nav_bar_projects_post_request: crate::models::TeamDirectoryProfilesProfileNavBarProjectsPostRequest) -> Result<(), Error<TeamDirectoryProfilesProfileNavBarProjectsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/nav-bar-projects", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_nav_bar_projects_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNavBarProjectsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove a project from the navigation bar
pub async fn team_directory_profiles_profile_nav_bar_projects_project_delete(configuration: &configuration::Configuration, profile: &str, project: &str) -> Result<(), Error<TeamDirectoryProfilesProfileNavBarProjectsProjectDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/nav-bar-projects/{project}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), project=crate::apis::urlencode(project));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNavBarProjectsProjectDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_notification_settings_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::GlobalNotificationSettings, Error<TeamDirectoryProfilesProfileNotificationSettingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/notification-settings", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNotificationSettingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_notification_settings_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_notification_settings_patch_request: Option<crate::models::TeamDirectoryProfilesProfileNotificationSettingsPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfileNotificationSettingsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/notification-settings", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_notification_settings_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileNotificationSettingsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a profile. Optional parameters will be ignored when null and updated otherwise.
pub async fn team_directory_profiles_profile_patch(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>, team_directory_profiles_profile_patch_request: Option<crate::models::TeamDirectoryProfilesProfilePatchRequest>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfilePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete personal token of the given profile
pub async fn team_directory_profiles_profile_permanent_tokens_current_delete(configuration: &configuration::Configuration, profile: &str) -> Result<(), Error<TeamDirectoryProfilesProfilePermanentTokensCurrentDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/permanent-tokens/current", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePermanentTokensCurrentDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get personal tokens used to access the current organization for the given profile
pub async fn team_directory_profiles_profile_permanent_tokens_get(configuration: &configuration::Configuration, profile: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesProfilePermanentTokensGet200Response, Error<TeamDirectoryProfilesProfilePermanentTokensGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/permanent-tokens", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePermanentTokensGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a personal token for the given profile that can be used to access the current organization
pub async fn team_directory_profiles_profile_permanent_tokens_post(configuration: &configuration::Configuration, profile: &str, applications_application_permanent_tokens_post_request: crate::models::ApplicationsApplicationPermanentTokensPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesProfilePermanentTokensPost200Response, Error<TeamDirectoryProfilesProfilePermanentTokensPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/permanent-tokens", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_permanent_tokens_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePermanentTokensPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a specific personal token used to access the current organization
pub async fn team_directory_profiles_profile_permanent_tokens_token_id_delete(configuration: &configuration::Configuration, profile: &str, token_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfilePermanentTokensTokenIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/permanent-tokens/{tokenId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), tokenId=crate::apis::urlencode(token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePermanentTokensTokenIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing personal token used to access the current organization. The name and/or scope of the personal token can be updated.
pub async fn team_directory_profiles_profile_permanent_tokens_token_id_patch(configuration: &configuration::Configuration, profile: &str, token_id: &str, applications_application_permanent_tokens_token_id_patch_request: Option<crate::models::ApplicationsApplicationPermanentTokensTokenIdPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfilePermanentTokensTokenIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/permanent-tokens/{tokenId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), tokenId=crate::apis::urlencode(token_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&applications_application_permanent_tokens_token_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfilePermanentTokensTokenIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Reactivate a user profile
pub async fn team_directory_profiles_profile_reactivate_patch(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>, team_directory_profiles_profile_reactivate_patch_request: Option<crate::models::TeamDirectoryProfilesProfileReactivatePatchRequest>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileReactivatePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/reactivate", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_reactivate_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileReactivatePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore a suspended user profile
pub async fn team_directory_profiles_profile_restore_patch(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileRestorePatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/restore", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileRestorePatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint will return profile information and Space personalisation data such as projects in the navigation bar, etc.
pub async fn team_directory_profiles_profile_settings_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::SettingsValue, Error<TeamDirectoryProfilesProfileSettingsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/settings", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSettingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_settings_patch(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_settings_patch_request: Option<crate::models::TeamDirectoryProfilesProfileSettingsPatchRequest>) -> Result<(), Error<TeamDirectoryProfilesProfileSettingsPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/settings", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_settings_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSettingsPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get spoken language of a profile
pub async fn team_directory_profiles_profile_spoken_languages_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdProfileLanguage>, Error<TeamDirectoryProfilesProfileSpokenLanguagesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/spoken-languages", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSpokenLanguagesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete spoken language for a profile
pub async fn team_directory_profiles_profile_spoken_languages_language_delete(configuration: &configuration::Configuration, profile: &str, language: &str) -> Result<(), Error<TeamDirectoryProfilesProfileSpokenLanguagesLanguageDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/spoken-languages/{language}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), language=crate::apis::urlencode(language));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSpokenLanguagesLanguageDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update spoken language for a profile. Optionally, firstName and lastName can be specified to add a localized name to the profile.
pub async fn team_directory_profiles_profile_spoken_languages_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_spoken_languages_post_request: crate::models::TeamDirectoryProfilesProfileSpokenLanguagesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdProfileLanguage, Error<TeamDirectoryProfilesProfileSpokenLanguagesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/spoken-languages", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_spoken_languages_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSpokenLanguagesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove association between the profile and the SSH public key
pub async fn team_directory_profiles_profile_ssh_keys_fingerprint_delete(configuration: &configuration::Configuration, profile: &str, fingerprint: &str) -> Result<(), Error<TeamDirectoryProfilesProfileSshKeysFingerprintDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/ssh-keys/{fingerprint}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), fingerprint=crate::apis::urlencode(fingerprint));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSshKeysFingerprintDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List SSH public keys associated with the profile
pub async fn team_directory_profiles_profile_ssh_keys_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::SshKeyData>, Error<TeamDirectoryProfilesProfileSshKeysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/ssh-keys", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSshKeysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Associate an SSH public key with the profile
pub async fn team_directory_profiles_profile_ssh_keys_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_gpg_keys_post_request: crate::models::TeamDirectoryProfilesProfileGpgKeysPostRequest) -> Result<(), Error<TeamDirectoryProfilesProfileSshKeysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/ssh-keys", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_gpg_keys_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSshKeysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Suspend a user profile
pub async fn team_directory_profiles_profile_suspend_patch(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>, team_directory_profiles_profile_suspend_patch_request: Option<crate::models::TeamDirectoryProfilesProfileSuspendPatchRequest>) -> Result<crate::models::TdMemberProfile, Error<TeamDirectoryProfilesProfileSuspendPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/suspend", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_suspend_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileSuspendPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get profile timezone. Returns profile's working hours timezone, location timezone or device timezone, whichever is present first in this list.
pub async fn team_directory_profiles_profile_timezone_get(configuration: &configuration::Configuration, profile: &str, dollar_fields: Option<&str>) -> Result<crate::models::ATimeZone, Error<TeamDirectoryProfilesProfileTimezoneGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/timezone", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileTimezoneGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_working_days_get(configuration: &configuration::Configuration, profile: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesProfileWorkingDaysGet200Response, Error<TeamDirectoryProfilesProfileWorkingDaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/working-days", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileWorkingDaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_working_days_post(configuration: &configuration::Configuration, profile: &str, team_directory_profiles_profile_working_days_post_request: crate::models::TeamDirectoryProfilesProfileWorkingDaysPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdWorkingDays, Error<TeamDirectoryProfilesProfileWorkingDaysPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/working-days", local_var_configuration.base_path, profile=crate::apis::urlencode(profile));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_working_days_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileWorkingDaysPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_working_days_working_days_id_delete(configuration: &configuration::Configuration, profile: &str, working_days_id: &str) -> Result<(), Error<TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/working-days/{workingDaysId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), workingDaysId=crate::apis::urlencode(working_days_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_profile_working_days_working_days_id_patch(configuration: &configuration::Configuration, profile: &str, working_days_id: &str, team_directory_profiles_profile_working_days_post_request: crate::models::TeamDirectoryProfilesProfileWorkingDaysPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdWorkingDays, Error<TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/{profile}/working-days/{workingDaysId}", local_var_configuration.base_path, profile=crate::apis::urlencode(profile), workingDaysId=crate::apis::urlencode(working_days_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_profile_working_days_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesProfileWorkingDaysWorkingDaysIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_widget_settings_widget_get(configuration: &configuration::Configuration, widget: &str, dollar_fields: Option<&str>) -> Result<crate::models::WidgetSettingsRecord, Error<TeamDirectoryProfilesWidgetSettingsWidgetGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/widget-settings/{widget}", local_var_configuration.base_path, widget=crate::apis::urlencode(widget));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesWidgetSettingsWidgetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn team_directory_profiles_widget_settings_widget_patch(configuration: &configuration::Configuration, widget: &str, team_directory_profiles_widget_settings_widget_patch_request: crate::models::TeamDirectoryProfilesWidgetSettingsWidgetPatchRequest) -> Result<(), Error<TeamDirectoryProfilesWidgetSettingsWidgetPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/widget-settings/{widget}", local_var_configuration.base_path, widget=crate::apis::urlencode(widget));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_profiles_widget_settings_widget_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesWidgetSettingsWidgetPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns pairs of profiles and their working days. If several working days settings are defined for the same profile then several pairs are returned.
pub async fn team_directory_profiles_working_days_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, profiles: Option<Vec<String>>, since: Option<&str>, till: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryProfilesWorkingDaysGet200Response, Error<TeamDirectoryProfilesWorkingDaysGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/profiles/working-days", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profiles {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("profiles".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("profiles", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = since {
        local_var_req_builder = local_var_req_builder.query(&[("since", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryProfilesWorkingDaysGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get/search all roles. Parameters are applied as 'AND' filters.
pub async fn team_directory_roles_get(configuration: &configuration::Configuration, query: Option<&str>, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdRole>, Error<TeamDirectoryRolesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryRolesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive a role
pub async fn team_directory_roles_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<TeamDirectoryRolesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryRolesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a role by ID
pub async fn team_directory_roles_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdRole, Error<TeamDirectoryRolesIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryRolesIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a role. Optional parameters will be ignored when null and updated otherwise.
pub async fn team_directory_roles_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, team_directory_roles_id_patch_request: Option<crate::models::TeamDirectoryRolesIdPatchRequest>) -> Result<crate::models::TdRole, Error<TeamDirectoryRolesIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_roles_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryRolesIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore an archived role
pub async fn team_directory_roles_id_restore_post(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdRole, Error<TeamDirectoryRolesIdRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles/{id}/restore", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryRolesIdRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a role
pub async fn team_directory_roles_post(configuration: &configuration::Configuration, team_directory_roles_post_request: crate::models::TeamDirectoryRolesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdRole, Error<TeamDirectoryRolesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/roles", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_roles_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryRolesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get statistics of total members, as well as members per location, role, and team. Parameters are applied as 'AND' filters.
pub async fn team_directory_stats_get(configuration: &configuration::Configuration, team_id: Option<&str>, location_id: Option<&str>, role_id: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::TdStats, Error<TeamDirectoryStatsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = team_id {
        local_var_req_builder = local_var_req_builder.query(&[("teamId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = location_id {
        local_var_req_builder = local_var_req_builder.query(&[("locationId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role_id {
        local_var_req_builder = local_var_req_builder.query(&[("roleId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryStatsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get or search all teams. Parameters are applied as 'AND' filters.
pub async fn team_directory_teams_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, with_archived: Option<bool>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersTeamsGet200Response, Error<TeamDirectoryTeamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = with_archived {
        local_var_req_builder = local_var_req_builder.query(&[("withArchived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel disbanding a team and restore its members
pub async fn team_directory_teams_id_cancel_disbanding_post(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<TeamDirectoryTeamsIdCancelDisbandingPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}/cancel-disbanding", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdCancelDisbandingPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Archive a team
pub async fn team_directory_teams_id_delete(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdTeam>, Error<TeamDirectoryTeamsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get or search direct members of a given team
pub async fn team_directory_teams_id_direct_members_get(configuration: &configuration::Configuration, id: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, query: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::ChatsChannelsChannelSubscribersUsersGet200Response, Error<TeamDirectoryTeamsIdDirectMembersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}/direct-members", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdDirectMembersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Disband a team
pub async fn team_directory_teams_id_disband_delete(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TdTeam>, Error<TeamDirectoryTeamsIdDisbandDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}/disband", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdDisbandDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a team by ID
pub async fn team_directory_teams_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdTeam, Error<TeamDirectoryTeamsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a team
pub async fn team_directory_teams_id_patch(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>, team_directory_teams_id_patch_request: Option<crate::models::TeamDirectoryTeamsIdPatchRequest>) -> Result<crate::models::TdTeam, Error<TeamDirectoryTeamsIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_teams_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restore an archived team
pub async fn team_directory_teams_id_restore_post(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::TdTeam, Error<TeamDirectoryTeamsIdRestorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/{id}/restore", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsIdRestorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new team
pub async fn team_directory_teams_post(configuration: &configuration::Configuration, team_directory_teams_post_request: crate::models::TeamDirectoryTeamsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TdTeam, Error<TeamDirectoryTeamsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&team_directory_teams_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get teams for synchronization with third-party system. Teams with etag greater than specified value are returned. Read more in the [documentation](https://www.jetbrains.com/help/space/sync-api.html).
pub async fn team_directory_teams_sync_batch_get(configuration: &configuration::Configuration, batch_info: &str, dollar_fields: Option<&str>) -> Result<crate::models::TeamDirectoryTeamsSyncBatchGet200Response, Error<TeamDirectoryTeamsSyncBatchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/team-directory/teams/sync-batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("batchInfo", &batch_info.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TeamDirectoryTeamsSyncBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get items for subject
pub async fn time_tracking_items_get(configuration: &configuration::Configuration, subject: &str, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::TimeTrackingItemsGet200Response, Error<TimeTrackingItemsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/time-tracking/items", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("subject", &subject.to_string())]);
    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TimeTrackingItemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete single work item
pub async fn time_tracking_items_item_id_delete(configuration: &configuration::Configuration, item_id: &str) -> Result<(), Error<TimeTrackingItemsItemIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/time-tracking/items/{itemId}", local_var_configuration.base_path, itemId=crate::apis::urlencode(item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TimeTrackingItemsItemIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a single work item.
pub async fn time_tracking_items_item_id_patch(configuration: &configuration::Configuration, item_id: &str, time_tracking_items_item_id_patch_request: Option<crate::models::TimeTrackingItemsItemIdPatchRequest>) -> Result<(), Error<TimeTrackingItemsItemIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/time-tracking/items/{itemId}", local_var_configuration.base_path, itemId=crate::apis::urlencode(item_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&time_tracking_items_item_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TimeTrackingItemsItemIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create work item.
pub async fn time_tracking_items_post(configuration: &configuration::Configuration, time_tracking_items_post_request: crate::models::TimeTrackingItemsPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TimeTrackingItem, Error<TimeTrackingItemsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/time-tracking/items", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&time_tracking_items_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TimeTrackingItemsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get all To-Do items that match given parameters. Parameters are applied as 'AND' filters.
pub async fn todo_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, open: Option<bool>, from: Option<&str>, till: Option<&str>, dollar_fields: Option<&str>) -> Result<crate::models::TodoGet200Response, Error<TodoGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/todo", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = open {
        local_var_req_builder = local_var_req_builder.query(&[("open", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = till {
        local_var_req_builder = local_var_req_builder.query(&[("till", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TodoGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete an existing To-Do item
pub async fn todo_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<TodoIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/todo/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TodoIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update an existing To-Do item. Optional parameters will be ignored when not specified and updated otherwise.
pub async fn todo_id_patch(configuration: &configuration::Configuration, id: &str, todo_id_patch_request: Option<crate::models::TodoIdPatchRequest>) -> Result<(), Error<TodoIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/todo/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&todo_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TodoIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new To-Do item, with an optional due date
pub async fn todo_post(configuration: &configuration::Configuration, todo_post_request: crate::models::TodoPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TodoItemRecord, Error<TodoPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/todo", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&todo_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TodoPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trusted_certificates_get(configuration: &configuration::Configuration, dollar_fields: Option<&str>) -> Result<Vec<crate::models::TrustedCertificate>, Error<TrustedCertificatesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/trusted-certificates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TrustedCertificatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trusted_certificates_id_delete(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<TrustedCertificatesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/trusted-certificates/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TrustedCertificatesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trusted_certificates_id_patch(configuration: &configuration::Configuration, id: &str, trusted_certificates_id_patch_request: Option<crate::models::TrustedCertificatesIdPatchRequest>) -> Result<(), Error<TrustedCertificatesIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/trusted-certificates/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&trusted_certificates_id_patch_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<TrustedCertificatesIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trusted_certificates_info_get(configuration: &configuration::Configuration, data: &str, dollar_fields: Option<&str>) -> Result<crate::models::CertificateInfo, Error<TrustedCertificatesInfoGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/trusted-certificates/info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("data", &data.to_string())]);
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TrustedCertificatesInfoGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn trusted_certificates_post(configuration: &configuration::Configuration, trusted_certificates_post_request: crate::models::TrustedCertificatesPostRequest, dollar_fields: Option<&str>) -> Result<crate::models::TrustedCertificate, Error<TrustedCertificatesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/trusted-certificates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&trusted_certificates_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<TrustedCertificatesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Block link unfurling for organization
pub async fn unfurls_block_unfurl_global_post(configuration: &configuration::Configuration, unfurls_block_unfurl_post_request: crate::models::UnfurlsBlockUnfurlPostRequest) -> Result<(), Error<UnfurlsBlockUnfurlGlobalPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/block-unfurl-global", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unfurls_block_unfurl_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UnfurlsBlockUnfurlGlobalPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Block link unfurling
pub async fn unfurls_block_unfurl_post(configuration: &configuration::Configuration, unfurls_block_unfurl_post_request: crate::models::UnfurlsBlockUnfurlPostRequest) -> Result<(), Error<UnfurlsBlockUnfurlPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/block-unfurl", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unfurls_block_unfurl_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UnfurlsBlockUnfurlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unfurls_check_blocked_post(configuration: &configuration::Configuration, unfurls_check_blocked_post_request: crate::models::UnfurlsCheckBlockedPostRequest) -> Result<bool, Error<UnfurlsCheckBlockedPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/check-blocked", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unfurls_check_blocked_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnfurlsCheckBlockedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unfurls_list_blocked_get(configuration: &configuration::Configuration, dollar_skip: Option<&str>, dollar_top: Option<i32>, dollar_fields: Option<&str>) -> Result<crate::models::UnfurlsListBlockedGet200Response, Error<UnfurlsListBlockedGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/list-blocked", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_skip {
        local_var_req_builder = local_var_req_builder.query(&[("$skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_top {
        local_var_req_builder = local_var_req_builder.query(&[("$top", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnfurlsListBlockedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unblock link unfurling for organization
pub async fn unfurls_unblock_unfurl_global_post(configuration: &configuration::Configuration, unfurls_block_unfurl_post_request: crate::models::UnfurlsBlockUnfurlPostRequest) -> Result<(), Error<UnfurlsUnblockUnfurlGlobalPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/unblock-unfurl-global", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unfurls_block_unfurl_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UnfurlsUnblockUnfurlGlobalPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unblock link unfurling
pub async fn unfurls_unblock_unfurl_post(configuration: &configuration::Configuration, unfurls_block_unfurl_post_request: crate::models::UnfurlsBlockUnfurlPostRequest) -> Result<(), Error<UnfurlsUnblockUnfurlPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/unfurls/unblock-unfurl", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unfurls_block_unfurl_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UnfurlsUnblockUnfurlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a URL that can be used to access attachment file without authentication
pub async fn uploads_chat_public_url_channel_message_attachment_id_get(configuration: &configuration::Configuration, channel: &str, message: &str, attachment_id: &str) -> Result<String, Error<UploadsChatPublicUrlChannelMessageAttachmentIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/uploads/chat/public-url/{channel}/{message}/{attachmentId}", local_var_configuration.base_path, channel=crate::apis::urlencode(channel), message=crate::apis::urlencode(message), attachmentId=crate::apis::urlencode(attachment_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UploadsChatPublicUrlChannelMessageAttachmentIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get meta information for a previously uploaded image
pub async fn uploads_image_id_get(configuration: &configuration::Configuration, id: &str, dollar_fields: Option<&str>) -> Result<crate::models::ImageAttachmentMeta, Error<UploadsImageIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/uploads/image/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = dollar_fields {
        local_var_req_builder = local_var_req_builder.query(&[("$fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UploadsImageIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Request a URL that can be used to upload an attachment. An attachment can be uploaded to the URL that is returned, by making a PUT request that has a proper content-type header and the attachment data as the request body. The PUT request returns a string that is an id of the uploaded attachment. The attachment id can be passed to other API methods where this attachment needs to be used. Attachments are available for download at `/d/{attachmentId}`. The 'storagePrefix' parameter can be one of file, maps, emoji or attachments. The 'mediaType' parameter can be omitted for all uploads. For image uploads that need to be resized automatically for specific use, such as chat stickers or emoji, use one of `chat-image-attachment`, `chat-sticker`, `emoji`.
pub async fn uploads_post(configuration: &configuration::Configuration, uploads_post_request: crate::models::UploadsPostRequest) -> Result<String, Error<UploadsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/uploads", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&uploads_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UploadsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

